A\*算法是一种图搜索算法, 用于寻找图中两个节点之间的最短路径

# 数据表示
在计算机中, 图通常被抽象表示为节点(nodes)和边(edges)
实际数据结构可用邻接矩阵或者邻接表之类的结构存储
A\*算法接收一个图, 一个开始节点和一个终点, 
返回两个节点之间的最短路径

# 图搜索算法
1. BFS: 最基础的算法, 向各个方向平等地搜索(将移动开销视为相等), 大部分图搜索算法的源
2. Dijkstra's Algorithm (Uniform Cost Search): 适用于处理移动开销不均匀时(例如有的图的边有不同的移动开销), 它会选择开销较小的路径优先搜索
3. A\*: 是 Dijksta 算法针对单个终点的优化, 最终找寻一个终点
![[Pasted image 20230926111358.png]]

# 从 BFS 开始
BFS 很熟悉了, 类似洪水一样向四周泛滥, 具体的执行流程就是从开始点出发, 访问开始点, 然后一次将它的邻居都收集, 然后对每个邻居做相同的操作(忽略已收集过的), 知道所有节点都被搜集访问过
为了实现这种"收集"和依次访问的功能, 使用队列来维护整个收集过程
![[Pasted image 20230926112713.png]]
但这样只是简单的广度优先遍历, 并没有寻找路径的功能

因此可以加上一个哈希表存储第一次访问到某个节点时的上一个节点(BFS 是层序遍历, 因此第一次访问到一个节点时的路径, 也一定是从该节点到开始点的最短路径), 因此在字典中存储, 该节点为键, 父节点为值, 在 BFS 完成后, 就可以通过读字典一步步反推得到终点到开始点的最短路径
![[Pasted image 20230926113652.png]]
读取路径:
![[Pasted image 20230926113819.png]]

除此之外还有很多情景都可以使用 BFS 搜索得到最短(路径/移动次数...), 
总之就是将图看作为状态, 将在图上的移动看作为改变状态, 这样很多"最短"问题都可以建模使用 BFS 搜索

剪枝: 在找到终点后, 就没必要继续完整地遍历整个图了, 使用剪枝结束无用搜索
![[Pasted image 20230926114433.png]]


# Dijkstra's Algorithm
在 BFS 中, 穿过每一条边的开销都是一样的, 也就是说此时寻找的最短路径只是节点之间相隔边最少的路径, 
但在实际中, 穿过不同的边开销可能是不同的, 因此在寻找开销最小(而不是相距边数最少)的路径时就需要使用 dijkstra 算法

dijkstra 算法的想法与 BFS 大致相同, 
为了维护从开始点开始的开销, 使用一个字典记录到达某个节点所需开销(只是记录到现在访问节点的时候, 会随着更小开销的出现而修改, 因此一个节点会可能被多次访问)
同时, 为了更快找到最短开销路径, dijkstra 算法将队列换成了优先队列, 由此可以优先访问那些最有可能存在于目标路径的节点

![[Pasted image 20230926133322.png]]

# 启发式搜索(Greedy Best First Search)
BFS 和 dijkstra's algorithm 都很好地完成了寻找通往所有或多个位置的路径, 
但有时并不需要所有位置的路径, 只需要寻找指定的开始点和终点之间的路径即可

因此为了避免盲目选择寻找方向, 引入一个启发函数(启发函数就是一个让搜索方向朝着目标前进的函数, 在本例中, 启发函数设置为当前点到目标点的距离(距离越近方向越对)), 并将优先队列中优先级改为与终点的距离, 这样做可以启发搜索向着终点的方向进行, 减少搜索用时
![[Pasted image 20230926140059.png]]
![[Pasted image 20230926140045.png]]

搜索用时是减少了, 但是贪心搜索不一定可以获得最佳(最短/最小开销)路径(特别是在有障碍物时)

# A\*算法
dijkstra 算法考虑了最短路径, greedy best first search 考虑了启发搜索方向,
为了同时考虑这两个优点, 可以将他们在优先队列中的优先级相结合, 简单的想法就是将这两个算法的优先级判断标准相加
![[Pasted image 20230926140842.png]]
从而得到 A\* 算法

source: [introduction to the A* algorithm]( https://www.redblobgames.com/pathfinding/a-star/introduction.html )