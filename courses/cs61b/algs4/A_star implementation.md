A\*算法的具体实现 [[A_star]]

# Graphs & Grids
图搜索算法中, 图(或者网格作为一种特殊的图)的表示是算法的重要部分,

但图搜索算法通常只需要了解图中节点的连接性(一个节点有哪些邻接节点, 如何获得这些邻接节点), 而并不需要考虑其他的例如图的布局, 结构, 节点的坐标之类的信息, 
它只需要知道每个节点的连接性

因此, 一个图通常可以由两个集合表示
1. 点集, 包含图中所有点的集合
2. 边集, 包含图中所有边的集合
例如:
![[Pasted image 20230930201742.png]]
只需要考虑:
![[Pasted image 20230930201808.png]]

点集, 边集在一起就可以完美地描述一个图的连接性


### Grids in graph form
网格是一种特殊的图
网格中所有的格子都可以看作是图中的一个节点
而每个节点可以上下左右移动到达邻接节点, 因此边是上下左右(对节点有限制时, 可能无法到达/拥有上下左右所有边)

例如一个 20\*10 的网格的图表示:
![[Pasted image 20230930202529.png]]
通过上下左右 4 边到达邻接节点:
![[Pasted image 20230930202618.png]]


# Python Implementation
python 实现

### BFS
1. Graph
如上, 图只需要提供节点之间的连接性质
因此一个图需要存储点, 边, 并提供一个查询点的邻接的函数
![[Pasted image 20230930210424.png]]
![[Pasted image 20230930210356.png]]

在这里没有显式地包含一个点集, 而是使用 TypeVar 泛型了一个 Location, 并且直接使用 edges 包括点集

例如一个字符串图:
![[Pasted image 20230930211412.png]]
实例化成图结构:
 ![[Pasted image 20230930211449.png]]

自此, 就可以在这个图上使用 BFS 了
![[Pasted image 20230930211754.png]]
输出:
![[Pasted image 20230930211810.png]]


矩形网格图:
![[Pasted image 20231001114911.png]]
网格作为图时, 每个格子都是一个节点, 上下左右移动到邻接节点(有时候遇到边界或者邻接节点不可通过时没有完整的上下左右可以移动),
因此在这个图的数据结构中, 设置了一个 width, 一个 height, 一个列表 walls, 获取邻接节点列表的函数 neighbors
