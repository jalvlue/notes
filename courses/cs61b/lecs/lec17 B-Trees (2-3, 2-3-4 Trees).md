- [x] Lecture video
- [x] Lecture note


[[11.1 Intro to Balanced Search Trees]]
[[11.2 B-Trees]]
[[11.3 B-Tree invariants]]

[[3.3 Balanced Search Trees]]


# BSTs
- `depth` 节点的深度, 定义为到达根节点需要经过多少条边, 根节点的深度为 0
- `height` 树的高度, 深度最大的节点的深度就是整个树的高度
- 对于有 `N` 个节点的树
	- 如果树的高度接近 `N`, 那么就说该树退化接近链表
	- 如果树的高度接近 `logN`, 那么就说这个树非常茂盛
- `BST` 的高度也就是树的形状跟节点的插入, 删除顺序非常相关
- 完全随机的插入/删除顺序会产生一个相对来说比较茂盛的树
- 但是很多情况下, 数据不一定是完全随机的, 在一些场景下可能会导致树非常瘦高, 从而效率非常低下, 因此需要其他办法 (B 树)
	

# B-Trees
- B 树, 一般常见的有
	- `2-3 Trees`, 一个节点有 `2-3` 个子节点, 阈值 `L=2`
	- `2-4 Trees`, 一个节点有 `2-4` 个子节点, 阈值 `L=3`
- B 树的核心思想是尽量过度填充树底部的节点, 同时不将新节点作为叶子节点插入, 从而避免树的高度过大, 从而导致退化 ![[Pasted image 20240706160901.png]]
- 对节点能承载的最大个数值进行限制, 一旦超过这个阈值个数, 就向上爆一个, 同时改变原节点的结构 ![[Pasted image 20240706161257.png]]
- 链式超过阈值 ![[Pasted image 20240706161520.png]]
- `get, insert` 的时间复杂度大概是 `Θ(logN)`


# B-Tree invariants
- 根据上面的规则, B 树有两个很好的不变量
	- 所有叶子节点到根节点的距离相等 (有相同的深度), 这个性质来自于节点爆开上浮
	- 具有 `K` 的值的非叶子节点, 有 `k+1` 个叶子节点
- 有了这两个不变量的保证, 不论值的插入顺序如何, B 树总是非常茂盛


# B-Tree runtime analysis
- `insert-O(logN)`
