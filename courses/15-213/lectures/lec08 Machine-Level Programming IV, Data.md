- 在程序眼中内存就是巨大的字节数组, 他不知道哪些是标量数据, 哪些是聚集数据, 全靠编译器指导在字节层面做操作
- 编译器则为各种聚集数据做了字节数组层面的建模
	- `array`
	- `struct`
	- `union`
	- `floating-point`

# Array
- 一维数组是连续的, 根据每个元素的大小, 以及元素个数确定总数据大小
- ![[Pasted image 20250317160349.png]]
- 二维数组也是连续的
- ![[Pasted image 20250317160422.png]]
- 多级数组有点像拉链数组
- ![[Pasted image 20250317160456.png]]

# Structs
- 结构体按照字段的声明顺序依次分配内存, 也是连续的 (理性模型下)
- ![[Pasted image 20250317160613.png]]

- 内存对齐 `alignment` 是一种特殊的技术, 用于将结构体各个字段都填充到一定规整的大小, 以增加效率
- 例如硬件加载内存可能是一次加载 `64-bits, 8-bytes`, 如果没有对齐则可能导致某一字段正好卡在两段 `8-bytes` 之间, 要对该字段做处理则需要额外的指令, 效率低
- 使用对齐则可以避免这样的问题, 虽然在存储上增加了一些负担
- 同时对齐可以更好地使用 `lea` 指令的特性, 能够在 `1, 2, 4, 8` 这几个 `scalar` 之间完美变换
- ![[Pasted image 20250317162256.png]]
- 结构体数组可能也需要额外的对齐, 来保证整个数组的对齐
- ![[Pasted image 20250317162424.png]]
- 高效对齐的方法: 将占地大的字段放在前面
- ![[Pasted image 20250317162455.png]]

# Floating- point
- 现代计算机上浮点数和整数的计算不走同一套东西
- 浮点数有自己的寄存器, 运算指令
- `xmmX` 寄存器, 一共 `16` 个, 每个 `16-bytes`
- ![[Pasted image 20250317162633.png]]
- `SIMD, single instruction multiple data`, 一个指令做多个运算, 核心是将运算参数向量化
- ![[Pasted image 20250317162738.png]]

# Summary
![[Pasted image 20250317162757.png]]
