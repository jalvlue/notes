- 人有十个手指, 因此自然地选择使用 `base-10` 来作为日常使用的计数法
- 计算机作为一种电子设别, 天然适合通过高低电压这种二值信号来表示数据, 同时二值信号可以表示一种互斥关系, `0 1` 表示有无
- 单个二进制位作用不大, 多个二进制位组合起来形成二进制位模式则有很大的作用, 作为一种集合可以表示无限的数据, 同时给位模式人为定义一些解释背景, 同一个位模式也可以被解释为不同的东西, 这是二进制位模式的强大之处
	- `ascii encoding`
	- `unsigned int`
	- `two's complement formant signed int`
	- `IEEE floating point`
- 二进制位模式也不能是无穷大的, 因此计算机系统会规定使用固定多少位来表示某种数据, 因此计算机中的数据是对现实世界的一种模拟, 无法完全达到数学理想模型 (溢出)

# 2.1 information storage
- 单一二进制位作用太有限, 因此计算机总是使用连续的 8 位来作为最小信息存储单位, 这样的 8 位也就是一个字节 `byte`
- 对应的, 内存的最小单位也是字节, 每一个字节都有自己对应的唯一编号, 称为内存地址

### 2.1.1 hexadecimal notation
- 十六进制, 大串的二进制位模式对于人类阅读非常困难, 因此引入十六进制, 将 4 个二进制位组合为一个十六进制位, 从而两个十六进制位组合为一个字节
![[Pasted image 20241220212057.png]]
- 小技巧: 只需要记住 `F: 1111, A: 1010, C:1100`, 其他的 `BDE` 都可以通过对 `AFC` 做加减得到
- 二进制-十进制-十六进制数字之间的相互转换: 这是计算机做的事情, 人类不应该手动做这种事


### 2.1.2 data size
- `word size`, 计算机系统的最基本参数之一, 具体来说就是系统中指针的大小, 例如 64 位系统指针大小为 `64-bit, 8-byte`, 也就是说它的字长是 `8-byte`, 从高维角度上来说, 字长代表了一个系统最经常处理的数据的大小, 是系统 cpu, 内存和其他硬件之间的一种约定
- `data-size`, cpu 的 `ISA` 通常会提供对 `1,2,4,8-byte` 大小数据操作的指令, 因此一个程序的数据大小通常由编译器决定
![[Pasted image 20241220213917.png]]
- 常见的 c 语言数据类型, 注意有一些类型是跨平台的, 有一些的大小是由平台决定的


### 2.1.3 addressing and byte-order

- 对于大小超过一个字节的数据, 例如 `int-4bytes, double-8bytes`, 需要确定两个标准
	- 这个数据的地址应该取哪个字节
	- 多字节数据内部的每个字节又是怎样排列的
- 大小超过一个字节的数据内存通常都是连续的, 因此取其首字节 (地址最小的那个字节)的地址作为整份数据的地址, 其延申的大小由类型系统和 c 编译器维护
- 常见的机器对于多字节数据内部都是使用小端字节序, 高字节在低地址, 例如 `0x01234567`, 会被存储为 `67 45 23 01`, 从低地址到高地址, 一共四个字节 [[little-endian 和 big-endian]]
![[Pasted image 20241220215147.png]]
- 例子: `4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip)` 就是一个小端序指令


### 2.1.4 representing strings
- C 语言中的字符串就是简单的字节数据, 同时由于是字节数组, 因此只兼容 `ascii` 字符集, 每一个字节代表一个 `ascii code point`, 为了区分字节数组的最后还会填上一个 `0x00`, 用于代表该字符串的结束


### 2.1.5 representing code
- 代码即数据, 从元编程的角度上看代码也是一种数据, 这是合理的, 代码本来就是在程序运行时被存储在代码段
- 因此代码也有它的二进制表示, 具体的, 就是程序被编译成二进制可执行文件之后, 每一个指令的二进制编码 (不同的指令的二进制编码长度可能不同)
```c
int sum(int x, int y) {
	return x + y;
}

Linux    32 55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows  55 89 e5 8b 45 0c 03 45 08 5d c3
Sun      81 c3 e0 08 90 02 00 09
Linux 64 55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
```

### 2.1.6 introduction to boolean algebra
![[Pasted image 20241220222415.png]]
- 布尔运算是计算机的基础, 拓展到二进制模式的布尔运算后发挥出更大的能力, 基础的二进制模式与或非异或构建了整个运算系统
![[Pasted image 20241220222525.png]]


### 2.1.7 bit-level operations in c
![[Pasted image 20241220222721.png]]


### 2.1.8 logical operations in c
![[Pasted image 20241220222846.png]]


### 2.1.9 shift operations in c
- 左移
- 逻辑右移
- 算数右移, 算数右移可以在精度丢失之前保持负数的大小, 这很有用
![[Pasted image 20241220223624.png]]


# 2.2 integer representations
- 计算机中整数被分为两类表示
	- 无符号整数, 统一使用 `unsigned representation` 表示
	- 有符号整数, 绝大部分都是使用 `two's complement` 来表示有符号整数
- 在整个学习过程中, 我们将整数分为这三类
	- `binary, B`, 数学意义上的整数对应的二进制模式表示
	- `unsigned, U`, 无符号整数表示
	- `two's complement, T`, 有符号整数表示
![[Pasted image 20241223144030.png]]


### 2.2.1 integral data types
- C 语言标准中有多种数据类型用于表示不同范围和作用的整数
![[Pasted image 20241223144344.png]]
- 可以看到, 对于有符号的整数, 负数的范围比正数大了一点, 0 在其中也占据了一个位模式
- 同时, 有符号和无符号可以表示的数字范围都是一样大的, 只是有符号的将其表示范围分为两半, 一般表示负数, 一般表示非负数

### 2.2.2 unsigned encodings
- 无符号整数与原本的二进制位模式实际上是一样的, 解读方式也是相同的, `w-bit` 可以表示 `0~2**w - 1`
- 另外一个特点是无符号整数和二进制模式是一一对应的, 也就是数学上的双射 `bijection`
![[Pasted image 20241223145459.png]]
![[Pasted image 20241223145507.png]]

### 2.2.3 two's complement encodings
- `two's complement` 在绝大部分场景下是表示有符号整数的最好方式
- 想法也非常简单, 将最高位的权重改为负权, 直接将整个表示范围一分为二 (负数, 非负数)
![[Pasted image 20241223205823.png]]
![[Pasted image 20241223205831.png]]
![[Pasted image 20241223205905.png]]
- 表示范围是 `-2**(w-1) ~ 2**(w-1) - 1`
- 同样也是双射, 二进制位模式和一个有符号整数之间是一一对应的
- 需要注意的是由于非负数有一个模式用来表示 0, 因此正数和负数之间范围并不是相同的

### 2.2.4 conversions between signed and unsigned
- 在同样位宽的有无符号整数的转换中, 他们底层的二进制位模式保持不变, 只是编译器对该位模式的解读方式(`context`)发生了变化
- 转换公式不需要记住, 只需要知道转换前解读方式-二进制位模式-转换后解读方式即可


### 2.2.5 signed versus unsigned in C
- C 语言标准和大部分编译器实现都支持有符号/无符号整数, 同时使用 `two's complement` 来编码有符号整数
- 同时二者之间的转换符合上述 [[ch2 Representing and Manipulating Information#2.2.4 conversions between signed and unsigned]]

### 2.2.6 expanding the bit representation of a number
- `unsigned`, 将长度扩大只需要涉及到在拓展出来的右方位上补 0, 也成为 `zero-extension`, 零拓展, 这样完全不会丢失精度
- `two's complement`, 则需要在前面补上该数的符号位, 这样能够保证负数和非负数一样精度不丢失
- 多应用在将一个小的数据类型转为大的, 例如 `short -> int`

### 2.2.7 truncating numbers
- 截断则简单很多, 直接将高位超过的那些二进制位全部丢弃, 然后再在当前 `context` 下解释获得的新的二进制位模式
- 多应用在将一个大的数据类型转为小的, 例如 `int -> short`

### 2.2.8 advice on signed versus unsigned
- 二者的混用, 随意的转换是导致问题的主要原因, 因此尽可能避免混用或者甚至不使用 `unsigned` 是一个不错的想法
- 但事实上 `unsigned` 如果不是简单地拿来表示整数, 而是利用其二进制模式位有一致的权重, 用来 `set`, 每一个 `bit` 表示某种事物的有无, 实际上也很有用


# 2.3 integer arithmetic
- 计算机世界中的整数算术跟数学理想模型有一些不同的地方, 这些不同点很可能导致的程序出现问题

### 2.3.1 unsigned addition
- 绝大部分的编程语言和编译器使用固定长度的位模式来表示无符号整数, 因此超出表示范围的无符号整数加法结果会导致溢出! 例如 `4` 位无符号整数范围是 `0~15`, 两个和则为 `0~30`, 必须使用 `5` 位才能充分表示
- 大部分编程语言和编译器的做法是将超出表示范围的加法称为溢出, 对溢出的处理则是直接抛弃最高位, 进行截断
- 截断的效果在数学上等同于对 `2**w-1` 取模
- 其实说到底就是固定的位数, 舍弃溢出的位, 在当前上下文之下对截断之后的结果进行解读
![[Pasted image 20241225204639.png]]


### 2.3.1 two's complement addition
- 有符号补码整数同样会遇到溢出的问题 (正溢出+负溢出)
- `4` 位有符号整数表示范围是 `-8~7`, 加法的结果则是 `-16~14`, 必须使用 `5` 位才能完全表示, 同样地, 舍弃溢出位, 在有符号补码的上下文解读截断后的结果
![[Pasted image 20241225205050.png]]


### 2.3.3 two's complement negation
![[Pasted image 20241225205203.png]]
- 由于补码非负数使用一个位模式来表示 0, 因此负数和正数是不对称的, `TMin = -TMax - 1`
- 从而导致对一个有符号补码整数取反, 需要注意 `TMin`
- 总的来说, 取反就是位模式翻转后+1


### 2.3.4 unsigned multiplication
- 相对于加法, 乘法导致的结果范围更加大, 需要 `2w` 位才能够完全表示, 同样的, 还是截断只低 `w` 位
- 数学上截断的效果同样是类似于对 `2**w` 取模


### 2.3.5 two's complement multiplication
- 有符号补码同样需要 `2w` 位才能完全表示, 同样截断至低 `w` 位


### 2.3.6 multiplying by constants
- 乘法指令所需要的 cpu 时钟比加法或移位指令长, 因此编译器会尽可能将乘法优化成加法
- 最典型的就是 `*2`, 此时只需要对位模式进行移位即可, 其他可组成 2 的次幂的也会尽可能优化成移位+加法
![[Pasted image 20241225210520.png]]

### 2.3.7 dividing by powers of 2
- 除法指令需要的 cpu 时钟甚至更多, 因此能优化尽可能优化
- 逻辑右移, 右移之后在高位空出的地方补上 0, C 语言中, 无符号整数右移就是逻辑的
- 算术右移, 右移之后在高位空出的地方补上最高位, C 语言中, 有符号补码整数的右移就是算术右移
- 算术右移的好处是, 对于一个负数, 在精度丢失之前, 它的结果是准确的, 且符号被很好地保留下来


### 2.3.8 final thoughts on integer arithmetic
- 可以看出, 在计算上, 无符号和补码在位模式上的行为是非常一致的, 只是对他们的解读方式导致了结果的不一样


# 2.4 floating point
- `IEEE floating point` 是目前计算机表示实数的事实标准
- 标准非常清晰, 优雅而易于理解

### 2.4.1 fractional binary numbers
- 从十进制小数出发 `98.76`, 在小数点之前, 每一位的权重依次降低直到 `10**0 = 1`, 在小数点之后权重仍然依次降低, 第一位的权重是 `10**-1 = 0.1`
- 二进制小数, 想法和十进制小数, 以及整数二进制位模式相同, `2**0 = 1, 2**-1 = 0.5`
![[Pasted image 20241225211728.png]]


### 2.4.2 IEEE floating-point representation
- 相比于直接使用二进制小数表示法, IEEE 使用了一种移位策略
- 具体分为
	- `S, sign`, 一位符号位
	- `E, exponent`, 数位指数位
	- `M, significand`, 数位精度位
	- 将所有的小数都使用 `s * 2**E * M` 的格式
- 具体地, IEEE 使用以下方式来编码这个小数表示格式
	- `s`, 符号位
	- `exp`, 对 `E` 的编码
	- `frac`, 对 `M` 的编码
![[Pasted image 20241228153034.png]]

- `normalized values`, 规格化的浮点数
	- `exp` 非全 `0, 1`, 此时的 `exp` 编码为 `base form`
	- `E = exp - bias, bias = 2**(k-1) - 1`, 也就是说, 此时的 `exp` 是进行加上 `bias` 变换后的编码, `bias` 取决于浮点数的精度, 如果是单精度有 8 位指数位, `k=8, bias = 2**7 - 1 = 127`
	- `exp` 非全 `0, 1`, 对于单精度 `1 <= exp <= 254`, 因此可以表示 `-126 <= E <= 127`
	- `exp` 这样编码为的是可以直接将 `exp` 看成是一个 `unsigned`, 在浮点数比较的时候可以直接将两个浮点数的 `exp` 做 `unsigned` 初步比较, 非常方便
	- `frac` 则将 `M` 编码为 `M = 1 + frac`, 也就是说, `frac` 作为小数点后的数, 永远都有一个前导的 `1`, 这样又可以增加一点精度
- `denormalized values`, 非规格化的浮点数
	- `exp` 全为 `0`
	- `E = 1 - bias`, 也就是说, 单精度表示 `E=-126`
	- `M = frac`, 没有前导的 `1`
	- 非规格化的出现主要有两个作用
		- 表示 0
		- 在 0 和规格化的浮点数之间有一个丝滑的过渡
- `special values`
	- `exp` 全为 `1`
	- `frac` 全为 `0` 表示溢出, 表示正无穷或负无穷
	- `frac` 非全为 `0` 表示非数, `NaN, not a number`, 通常是非法运算导致的结果

### 2.4.3 example numbers
![[Pasted image 20241228155318.png]]
- `norm` 表示正常的小数
- `de-norm` 表示零以及接近零的小数

![[Pasted image 20241228155355.png]]
- 从这里也可以看出 `de-norm` 和 `norm` 之间丝滑的过渡
- 而且随着指数位的增加, 精度位的保持精度能力越来越小, 从而导致越靠近 0 的小数越密集, 越远离 0 的小数越稀疏

### 2.4.4 rounding
- 在精度不足时, 如何尽可能地表示, 就涉及到 `rounding` 了
- 总体上, 有 4 中 `rounding`
	- `round-to-even`
	- `round-toward-zero`
	- `round-down`
	- `round-up`
![[Pasted image 20241228172649.png]]
- `round-to-even` 是浮点数中最常用的一种策略, 也是 IEEE 浮点数标准中默认的策略

### 2.4.5 floating-point operations
- `IEEE` 浮点数的运算都需要加上一步 `rounding`, 因此所有的运算操作都可以看成是 `Round(x op y)`
- `rounding` 的存在导致浮点数运算可能会产生意想不到的结果
	- `(3.14+1e10) - 1e10 = 0.0`
	- `3.14 + (1e10-1e10) = 3.14`

### 2.4.6 floating point in C
- `float`
- `double`
- `INFINITY`
- `NAN`
- `casting`
	- 不同精度的浮点数之间, 整型到浮点数之间的转换跟整型转换不同, 该数的位模式会改变, 而值会尽可能地保持
	- `int -> float`, 不会溢出, 但是可能会因为浮点数无法表示该数而导致 `rounding`, `float` 只有 20 多位的精度位, 无法完全覆盖 `int`
	- `int/float -> double`, 不会溢出, 没有 `rounding`, `double` 的精度和表示范围都完全覆盖 `int/float`
	- `double -> float`, 可能溢出, 可能 `rounding`
	- `float/double -> int`, 可能溢出, 使用 `round-toward-zero` 策略


# 2.5 summary
- 数据在内存中的表示格式是查看程序底层代码时必须了解的
- 内存被操作系统抽象之后在程序的严重就是一个巨大的字节数组
- 一个字节包含 8 个二进制位, 是内存的最小操作单位, 所有的字节都有字节的唯一编码, 称为该字节的地址
- 所有的数据都以一组字节序列的格式在内存中存在, 该数据的地址就是首字节地址, 该数据多字节内部的排序则按照大端小端序
- 整数数据包括两种编码规则
	- `unsigned`
	- `sing, two's complement`
- 浮点数通常采用 `IEEE floating-point 754`
	- `float, single-precision`
	- `double, double-precision`
- 由于大多数编译器对数据采用固定大小的字节空间来表示, 因此需要注意在运算或者转换的溢出问题

