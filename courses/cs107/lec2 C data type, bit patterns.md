### 二进制系统
- 一个bit可以表示0和1两个值
- 多个bit合成一组可以表示更多值
    - 8bit表示2^8=256个值,即可以表示ASCII码表中的字符
    - 16bit表示2^16=65536个值
- 计算机内存中以二进制形式存储数值
    - 例如字母A的ASCII码为65,在内存中表示为01000000

### 数据类型
- 布尔型(bool):通常占1bit,表示true和false
- 字符型(char):通常占1字节(8bit)
- 短整型(short):占2字节,可以表示0到2^16-1之间的整数
- 整型(int):通常占4字节,可以表示更大范围的整数
- 浮点型(float):占4字节,尝试用有限字节表示浮点数
- 双浮点型 (double): 占 8 字节, 表示更高精度的浮点数

### 位模式
###### one's complement: 
用最开始一位来表示符号, 对于正数和负数, 只有首位不一样
例如 8 位数字:
- 0000 0111 --> +7
- 1000 0111 --> -7
这样子带来的后果是:
- 对于符号不同的数进行加减时, 无法正确使用简单的加减规则
- `0` 有两种表示

###### two's complement:
想法是从正数出发, 然后通过规则获得与这个正数进行简单加减之后等于 `0` 的对应负数

刚好反码有很好的性质就是:
- 0000 0111 --> +7
- 1111 1000 --> +7 的反码
---
- 1111 1111 --> 全 `1`
- 0000 0001 --> +1, 再加上 `1` 则溢出, 得到 `0`, 因此可以在正数反码的基础上, 再加上 `1` 得到 `补码` , 使得正数与 `补码` 相加等于 `0`,从而得到对应的负数表示, 从此 `0` 也只有一个表示

- 0000 0111 --> +7
- 1111 1001 --> -7
---
- 0000 0000 --> 0

### 位复制
###### 短位复制到长位
```C
char ch = 'A';
short s = ch;
```
对于这种正数的, 目标拥有更多位数的, 可以直接复制到低位过去, 高位置为 `0`

```C
short s = -1;
int i = s;
```
对于这种负数的, 采用 `符号拓展`, 目标的高位会填充为源的最高位 `1`

###### 长位复制到短位
```C
short s = 65;
char ch = s;
```
目标只会将源的低位复制过去, 对于高位则直接丢弃

### 浮点数表示
float: 32bits
对于 `int`, 使用 `2^31~2^0` 来解释位模式, 因此做一些迁移

让位模式解释位 2 的负次幂, 就可以用来表示一定精度的浮点数了
例如 32bits 中, 解释为 `2^11~2^-20` 来表示浮点数

浮点数标准做的也是基于这种思想的
具体的协议没什么意思