# Isolation
隔离性是为什么计算机需要 os 的一大原因
现代计算机需要在有限的资源下同时运行多个程序, 因此就需要复用硬件

如果没有 os 的隔离, 程序直接与硬件交互:
- 一个程序的行为不应该影响到其他程序
- CPU, 那么程序就需要自动地让出 CPU
- 内存, 多个程序的数据代码和栈直接存储在物理内存中, 边界感知很弱, 一不小心就覆盖了其他程序的内存
- ...

因此隔离性是重要其且必须的, 操作系统使用进程抽象来实现隔离性, 并复用硬件

```ad-faq
进程本身不是 CPU，但是它们对应了 CPU，它们使得你可以在 CPU 上运行计算任务。
应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。
```

同时, 文件系统也是一个实现隔离的抽象, 用户通过文件系统而不是直接操作磁盘

# Defensive
操作系统需要做好最坏的打算, 时刻与应用程序保持强隔离
不能相信应用程序
通常来说, 强隔离需要硬件的支持, xv6 中包括:
- kernel mode, user mode
- virtual memory


# 硬件对于强隔离的支持
### kernel mode & user mode
 - 运行在 kernel mode: CPU 可以执行特权指令 (privileged instructions), 例如设置 `page table` 寄存器, 关闭时钟中断, 修改处理器上的各种状态等
 - 运行在 user mode: CPU 只可以执行普通权限指令 (unprivileged instructions), 例如两个寄存器相加 ADD, 两个寄存器值相减 SUB, 跳转指令 JRC, BRANCH


应用程序异常行为: 在用户态尝试执行特权指令, 此时会有异常处理程序 (内核), 拒绝执行该程序, 并跳入内核, 对异常应用程序进行处理


```ad-question
学生提问：如果kernel mode允许一些指令的执行，user mode不允许一些指令的执行，那么是谁在检查当前的mode并实际运行这些指令，并且怎么知道当前是不是kernel mode？是有什么标志位吗？

Frans教授：是的，在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，就像在运算时不能除以0一样。

同一个学生继续问：所以，唯一的控制方式就是通过某种方式更新了那个bit？

Frans教授：你认为是什么指令更新了那个bit位？是特殊权限指令还是普通权限指令？（等了一会，那个学生没有回答）。很明显，设置那个bit位的指令必须是特殊权限指令，因为应用程序不应该能够设置那个bit到kernel mode，否则的话应用程序就可以运行各种特殊权限指令了。所以那个bit是被保护的，这样回答了你的问题吗？

学生提问：考虑到安全性，所有的用户代码都会通过内核访问硬件，但是有没有可能一个计算机的用户可以随意的操纵内核？

Frans教授：并不会，至少小心的设计就不会发生这种事。或许一些程序会有额外的权限，操作系统也会认可这一点。但是这些额外的权限并不会给每一个用户，比如只有root用户有特定的权限来完成安全相关的操作。

同一个学生提问：那BIOS呢？BIOS会在操作系统之前运行还是之后？

Frans教授：BIOS是一段计算机自带的代码，它会先启动，之后它会启动操作系统，所以BIOS需要是一段可被信任的代码，它最好是正确的，且不是恶意的。

学生提问：之前提到，设置处理器中kernel mode的bit位的指令是一条特殊权限指令，那么一个用户程序怎么才能让内核执行任何内核指令？因为现在切换到kernel mode的指令都是一条特殊权限指令了，对于用户程序来说也没法修改那个bit位。

Frans教授：你说的对，这也是我们想要看到的结果。可以这么来看这个问题，首先这里不是完全按照你说的方式工作，在RISC-V中，如果你在用户空间（user space）尝试执行一条特殊权限指令（后面Frans那边的Zoom就断了，等他重新接入，他也没有再继续回答，所以后半段回答是我补充的）用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限指令。
```

### virtual memory
基本上, 所有的 CPU 都支持虚拟内存, 来获得更高的隔离性

虚拟内存的意思就是将实际的物理内存映射为给每一个进程的, 在逻辑上看似完整的虚拟内存
内核通过页表 `page table` 来记录这一映射关系

每一个进程都会有自己的独立的 `page table`, 因此只能访问出现在自己 `page table` 中的物理内存
内核会设置 `page table`, 让每一个进程都有不重合的物理内存
同时, 也防止了进程随便编造一个物理内存来访问

![[Pasted image 20240502134337.png]]
- 两个程序 `ls` 和 `echo` 都有自己的, 从 `0` 开始的虚拟内存
- 由于操作系统的页表会将这两个 `0` 地址映射到不同的实际物理内存地址, 因此他们被隔离开了


# User/Kernel mode 切换
![[Pasted image 20240507194419.png]]
之前说过很多, 用户程序通过 `系统调用` 进入内核态, 执行系统调用的权限指令, 这个模式转换的具体流程到底是怎样实现的

在 RISC-V 中，有一个专门的指令用来实现这个功能，叫做 ECALL。ECALL 接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行 ECALL 指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的 System Call。

执行 `ecall` 指令之后, CPU 会进入内核态, 并跳转执行到制定的位置(也就是 `syscall.c/syscall()`, 这个函数就是属于内核中的, 他会根据 `ecall` 中的参数, 在内核中执行对应的系统调用函数)
详见 [[ch2 Operating system organization#系统调用过程]]

用户空间和内核空间的界限是一个硬性的界限, 用户不能直接调用 `fork()`, 只能通过 `syscall - ecall - fork()` 这样的方式执行

```ad-question
学生提问：操作系统在什么时候检查是否允许执行fork或者write？现在看起来应用程序只需要执行ECALL再加上系统调用对应的数字就能完成调用，但是内核在什么时候决定这个应用程序是否有权限执行特定的系统调用？

Frans教授：是个好问题。原则上来说，在内核侧实现fork的位置可以实现任何的检查，例如检查系统调用的参数，并决定应用程序是否被允许执行fork系统调用。在Unix中，任何应用程序都能调用fork，我们以write为例吧，write的实现需要检查传递给write的地址（需要写入数据的指针）属于用户应用程序，这样内核才不会被欺骗从别的不属于应用程序的位置写入数据。

学生提问：当应用程序表现的恶意或者就是在一个死循环中，内核是如何夺回控制权限的？

Frans教授：内核会通过硬件设置一个定时器，定时器到期之后会将控制权限从用户空间转移到内核空间，之后内核就有了控制能力并可以重新调度CPU到另一个进程中。我们接下来会看一些更加详细的细节。

学生提问：这其实是一个顶层设计的问题，是什么驱动了操作系统的设计人员使用编程语言C？

Frans教授：啊，这是个好问题。C提供了很多对于硬件的控制能力，比如说当你需要去编程一个定时器芯片时，这更容易通过C来完成，因为你可以得到更多对于硬件资源的底层控制能力。所以，如果你要做大量的底层开发，C会是一个非常方便的编程语言，尤其是需要与硬件交互的时候。当然，不是说你不能用其他的编程语言，但是这是C成功的一个历史原因。

学生提问：为什么C比C++流行的多？仅仅是因为历史原因吗？有没有其他的原因导致大部分的操作系统并没有采用C++？

Frans教授：我认为有一些操作系统是用C++写的，这完全是可能的。但是大部分你知道的操作系统并不是用C++写的，这里的主要原因是Linus不喜欢C++，所以Linux主要是C语言实现。
```

# 宏内核, 微内核
[[ch2 Operating system organization#2.3 Kernel organization]]

- 宏内核性能好, 内核中运行大量服务, 代码多, 容易出错
- 微内核将一部分非核心的服务运行在用户态中, 内核代码少, 但是用户程序和用户态系统服务交互需要通过内核, 因此性能损耗高


# 编译运行 kernel 
- `xv6` 是宏内核的, 所有跟内核相关的代码都在 `kernel/` 目录下, 这些代码可以编译链接成一个可执行程序 `kernel`, 这个程序就是在 `kernel space` 中运行的操作系统内核
![[Pasted image 20240507200954.png]]

![[Pasted image 20240507201023.png]]
![[Pasted image 20240507201028.png]]

然后使用 `QEMU` 就可以模拟一个 RISC-V 处理器了
![[Pasted image 20240507201157.png]]
- -kernel：这里传递的是内核文件（kernel 目录下的 kernel 文件），这是将在 QEMU 中运行的程序文件。
- -m：这里传递的是RISC-V虚拟机将会使用的内存数量
- -smp：这里传递的是虚拟机可以使用的CPU核数
- -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件

# QEMU
QEMU 仿真了一个 RISC-V 计算机系统

当我们说 QEMU 仿真了 RISC-V 处理器时，背后的含义是什么？

直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情：
- 读取4字节或者8字节的RISC-V指令。
- 解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。
- 之后，在软件中执行相应的指令。

这基本上就是 QEMU 的全部工作了，对于每个 CPU 核，QEMU 都会运行这么一个循环

为了完全模拟 CPU 计算过程, QEMU 主循环需要维护寄存器状态, 因此会声明 C 语言变量来作为寄存器使用
![[Pasted image 20240507201426.png]]


# xv6 启动过程
[[ch2 Operating system organization#2.6 Code starting xv6, the first process and system call]]



