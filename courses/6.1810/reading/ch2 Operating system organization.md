# Overview
os 的关键需求
1. 就是满足多个程序同时运行, 因此 os 需要对进程 `时分` 硬件
2. os 还需要满足隔离性, 一个坏进程不会影响到其他进程的运行
3. os 还需满足进程间通信

`multiplexing, isolation, and interaction.`

xv6 在多核 RISC-V 微处理器上运行, 大部分底层功能是 RISC-V 特有的, RISC-V 是 64 位 CPU

os 的组织就是基于以上需求以及硬件条件来的

# 2.1 Abstracting physical resources
`ch1` 中所提及的系统调用看起来就像是库函数一样, 既然如此, 为什么使用 os 接口, 而不是程序自己实现一个需要的库, 并以最适合自己的方式使用硬件资源呢

这样做的话, 为了满足多个程序同时运行(都能分配到 CPU), 就需要应用执行一段时间后自动让出 CPU, 以便让其他程序可以运行, 
如果所有程序都是表现优良, 愿意自动让出 CPU, 那么这种方式是可行的, 但现实是程序大多都会尽可能占用 CPU 时间, 自动让出太过共产主义了

因此需要有一个更高权限的存在, 为所有程序创造强隔离, 禁止应用程序直接访问敏感的硬件资源, 而是通过抽象为应用程序提供服务(例如 os 提供 `open(), read(), write()` 服务, 让应用程序通过系统调用与存储进行交互, 而不是直接读写磁盘), 
并在进程之间透明地切换 CPU (`transparently switches hardware CPUs`), 保存进程的寄存器状态, 让每个程序都有运行的机会, 同时让进程意识不到时分的存在, 认为自己一直在占有 CPU

xv6 的系统调用接口既能为应用程序提供方便的服务, 也保证了进程间的强隔离性, 是抽象资源的很好的方式

# 2.1 User mode, supervisor mode, and system calls
[[2. Operating system organization#Overview|Overview]] 中第二点提到的满足隔离性, 需要 os 限制应用进程修改访问 os 的数据结构和指令, 并限制应用进程访问其他进程的内存空间

CPU 为强隔离提供了硬件支持
xv6 中, RISC-V CPUs 在执行指令时有三种模式: `machine mode, supervisor mode, user mode`

`machine mode` 用于 xv6 刚启动时配置计算机, 是 CPU 的初始状态, 拥有完整的权限, 执行几行初始配置计算机的指令之后 CPU 就会进入 `supervisor mode`

`supervisor mode` 可以执行特权指令(`privileged instructions`, 中断, 读写文件、寄存器等), 此时处于 `kernel space`, 这里的软件就是操作系统内核 `kernel`

应用进程只能执行 `user mode` 指令(加减计算等), 此时处于 `user space`, 如果尝试执行特权指令, 那么 CPU 将不会执行, 而是跳转到 `supervisor mode`, 并结束这个进程

要调用内核函数(如 xv6 中的 `read()` 系统调用)的应用程序必须过渡到内核, 应用程序不能直接调用内核函数
CPU 提供了一个特殊的指令来实现从 `user mode` 转到 `supervisor mode`, 然后进入内核指定的位置开始执行内核指令
然后内核就可以验证系统调用的参数(例如检查传递给系统调用的地址是否是应用程序内存的一部分), 并决定是否执行该操作

因此从 `user mode` 转到 `kernel mode` 的入口很关键, 必须由内核指定

# 2.3 Kernel organization
xv6 是宏内核的, 内核实现了完整的操作系统

### monolithic kernel
宏内核, 整个操作系统都处于内核中, 所有系统调用都必须运行在 `supervisor mode` 
优点是 os 不同部分可以更容易合作(例如, 操作系统可能会有一个缓冲存储器，可以由文件系统和虚拟内存系统共享)
缺点是 os 不同部分之间的接口可能很复杂, 因此增加代码量从而增加出错的可能性, 导致系统崩溃重启的概率增大

# microkernel
微内核, 让尽可能少部分的操作系统处于内核中, 运行在 `supervisor mode`, 让其余部分都运行在 `user mode`
![[Pasted image 20240402134058.png]]
在上图例子中, os 文件系统就作为一个用户空间进程运行在 CPU user mode, 作为用户进程运行的 os 系统服务称为服务器 (`server`)

在微内核中, 内核接口由一些用于启动应用程序、发送信息、访问设备硬件等的底层函数组成
这种组织结构使内核相对简单, 因为大部分操作系统都位于用户级服务器中


# 2.4 Code: xv6 organization
![[Pasted image 20240402134959.png]]


# 2.5 Process overview
xv6 的隔离单位是进程, 进程抽象将这些所有进程和内核相互隔离开, 防止一个进程行为不良(修改访问内核指令, 访问其他进程的内存空间等)对系统造成伤害

内核用于实现进程的机制包括:
- 用户/监管模式标识
- 地址空间
- 线程的时间分割

进程抽象给程序一种运行在只属于自己的私有计算机上, 拥有其他的进程无法访问的私有的完整内存地址空间(`virtual address`), xv6 使用页表实现这一功能(由硬件提供支持)
xv6 的 RISC-V 页表提供了 `virtual address -> physical address` 的翻译

![[Pasted image 20240402192825.png]]
进程的虚拟内存空间: 从虚拟地址 `0` 开始, 依次是 `instructions->global variables->stack->heap`

最大虚拟地址: `MAXVA`
1. RISC-V 指针为 64 位, 最大寻址地址位 `2^64-1`
2. 在页表中查询虚拟地址时, 硬件使用 64 位中的低 39 位 (页表使用了高 25)
3. xv6 使用了 39 位中的 38 位

因此, 对于最大虚拟地址, `MAXVA = 2^38-1 = 0x3fffffffff`

内核为每一个进程都保存了许多状态, 在 xv6 的源码中, 使用一个结构体 `struct proc` 存储进程状态
![[Pasted image 20240403135000.png]]
具体来说最重要的主要有三个:
1. `pagetable`, 进程的页表
2. `context`, 进程的运行状态
3. 内核栈==???==

每一个进程都有一个执行线程, 负责执行进程的指令, 线程可以暂停然后再恢复
os 的进程间透明切换就是暂停一个进程的执行线程, 并恢复另一个进程的执行线程, 线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中

每一个进程都有两个栈: 用户栈和内核栈, 分别存储在用户空间和内核空间执行的状态

进程的执行线程就在这两个栈之间切换

### 系统调用过程
进程可通过执行 RISC-V `ecall` 指令进行系统调用, 这个指令将提高 CPU(硬件) 的权限, 然后将 `PC` 置为内核指定的入口, 然后开始在 `supervisor mode` 执行内核代码, 此时执行线程的中间执行状态放在内核栈中

内核代码执行结束之后, 进程通过 `sret` 指令, 让执行线程转回用户栈, 并返回用户空间, 


### 总结
进程抽象包含两个设计理念:
1. 虚拟地址空间, 让进程产生拥有自己的内存的错觉
2. 线程, 让进程产生拥有自己的 CPU 的错觉

在 xv6 中, 一个进程由一个线程和一个地址空间组成

# 2.6 Code: starting xv6, the first process and system call

1. RISC-V 计算机启动后, 硬件首先初始化自己, 然后运行一个存放在 ROM 中的 `boot loader`, 这个 `boot loader` 将 xv6 内核加载到内存中, 开始运行内核代码

2. 此时 CPU 处于 `machine mode`, xv6 内核代码的入口是 `kernel/entry.S::_entry`
![[Pasted image 20240403145532.png]]
这里主要工作是为每一个 CPU 都设置了一个栈(预定义在 `start.c` 中, 每个 CPU 4096KB 的栈), 从而使 CPU 可以运行 C 代码, 然后调用 `start.c` 中的 `start()`

3. `start()` 做了很多只能在 CPU `machine mode` 中的配置 (目前还看不懂), 并将返回地址设置为 `main.c` 中的 `main()`, 然后使用 RISC-V 的 `mret` 指令, 使 CPU 进入 `supervisor mode`
![[Pasted image 20240403150333.png]]

4. 此时 `PC` 指向 `main()`, 开始执行 `supervisor mode` 下的 CPU 配置, 并在最后让所有 CPU 都执行 `scheduler()`, 开始进程调度
![[Pasted image 20240403150542.png]]
这里需要注意的是, CPU0 最后调用了 `userinit()`, 启动第一个用户程序

5. 第一个用户程序, RISC-V 汇编的 `user/initcode.S`, 这里直接将这个程序的机器码硬编码到 `uchar initcode[]` 中, 直接调用
![[Pasted image 20240403151508.png]]
原汇编代码 `user/initcode.S`:
![[Pasted image 20240430233248.png]]

`allocproc()` 函数会为进程初始化进程状态, 并将进程写入全局进程表中, 以便 CPU 调度器找到进程并调度进程
![[Pasted image 20240403151208.png]]
![[Pasted image 20240403151131.png]]
![[Pasted image 20240403151143.png]]

6. CPU 调度器发现第一个用户进程, 并选择调度
![[Pasted image 20240403151234.png]]
第一个用户程序 `user/inicode.S` 开始运行
![[Pasted image 20240403151712.png]]
这里主要做了两件事(正如注释中的对应 C 代码, 执行系统调用 `exec(init, argv)` 以及退出系统调用), 
具体来说将需要执行的系统调用编号放进 `a7` 寄存器中, 然后使用 RISC-V `ecall` 指令开始系统调用
![[Pasted image 20240403152333.png]]
系统调用中, 根据 `a7` 寄存器中的内容找到对应要执行的系统调用, 然后执行, 并将结果放在 `a0` 寄存器中(这里是`sys_exec`),

7. 系统调用 `exec(init, argv)`, 这里的 `sys_exec` 函数负责解析用户态传递的参数，创建一个新的进程来执行这些参数，并在必要时释放分配的内存。
![[Pasted image 20240403152528.png]]
![[Pasted image 20240403152538.png]]
这里 `exec()` 的程序是用户程序 `user/init.c`
![[Pasted image 20240403152730.png]]
它会打开 `console`, 然后, `fork()+exec()` 一个 `user/sh.c`
至此, 系统启动结束, 开始提供服务

# 2.7 Security Model
os 如何应对 bug 或者恶意代码

操作系统必须假定进程的用户级代码会尽力破坏内核或其他进程:
1. 用户代码可能会在其允许的地址空间之外尝试取消引用指针；
2. 可能会尝试执行任何 RISC-V 指令，甚至是那些并非为用户代码设计的指令；
3. 可能会尝试读写任何 RISC-V 控制寄存器；
4. 可能会尝试直接访问设备硬件；
5. 可能会向系统调用传递巧妙的值，试图诱使内核崩溃或做傻事。

内核的目标是限制每个用户进程，使其只能读/写/执行自己的用户内存，使用 32 个通用 RISC-V 寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须阻止任何其他操作。这通常是内核设计的绝对要求

对内核自身代码的期望则完全不同:
1. 内核代码被认为是由善意而谨慎的程序员编写的。
2. 人们希望内核代码没有错误，当然也不会包含恶意代码。

这一假设影响了我们分析内核代码的方式。例如，有许多内核函数（如自旋锁），如果内核代码使用不当，就会导致严重问题。
在检查任何一段特定的内核代码时，我们都想让自己相信它的行为是正确的。
不过，我们假定内核代码总体上是正确编写的，并遵循了使用内核自身函数和数据结构的所有规则。在硬件层面，假定 RISC-V CPU、RAM、磁盘等按照文档中的宣传运行，没有硬件漏洞

# 2.8 Real world
大多数操作系统都采用了进程的概念，大多数进程看起来都与 xv6 类似。
不过，现代操作系统支持在一个进程中包含多个线程，以允许单个进程利用多个 CPU。
在一个进程中支持多个线程需要大量 xv6 所不具备的机制，包括潜在的接口变化（如 Linux 的 `clone`，`fork` 的一种变体），以控制线程共享进程的哪些方面。
