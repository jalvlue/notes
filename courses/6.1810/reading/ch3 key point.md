- Os 为每个进程提供私有的地址空间和内存
- 页表决定了每块内存的意义, 以及实际物理内存的访问权限
- 从而让保证了进程的隔离性同时对一块物理内存进行复用
- xv6 使用虚拟内存的tricks
	- 将同一块物理内存映射到多个虚拟内存上 (trampoline page)
	- 使用一个未映射的 page 保护内核栈和用户栈 (防止栈溢出)

# 3.1 paging hardware
- 用户和内核都通过虚拟内存对实际物理内存进行操作
- Xv 6 使用 Sv 39 RICS-V, 虚拟地址的高 25 位不使用, 只是用后 39 位
	- 后 39 中的后 12 位作为页内 offset
	- 前 27 位作为页表项个数 (一共 `2^27` 个页表项)
- 每一个页表项共由 56 位组成
	- 44 位实际物理地址
	- 10 位控制 flags
![[Pasted image 20240518164104.png]]
- 在上图中可以看出, 实际物理地址也有 8 位的空闲可以使用
- Sv 39 RISC-V 已经相当够用了, 此外还有 Sv 48 RISC-V
- Xv 6 采用三级页表
	- 省空间
	- 但是 CPU 需要多次查询(使用 TLB(Translation Look-aside Buffer, 快表缓存减轻))
![[Pasted image 20240518164723.png]]
- 页权限 flags
	- V
	- R
	- W
	- ...
- 进程要使用页表时, 需要将它的根页表地址写进 CPU 的 `satp` 寄存器中 (实际上发生在上下文切换的过程中), 然后 CPU 就可以通过这个根页表查询该进程虚拟内存对应的物理地址

# 3.2 kernel address space
![[Pasted image 20240518171126.png]]
- 内核内存分布, 内核同样也是使用虚拟内存, 但是对于一些特殊的使用直接映射, 也就是虚拟内存和实际物理内存相同
	- 一些设备 `0x0~0x80000000`
	- RAM, `0x80000000~0x88000000`, 因此有一些实际物理页面在 kernel 的虚拟地址空间中被映射了多次(trampoline 和 kernel stack)

# 3.3 code: creating an address space
- `pagetable_t`, 指向一个 RISC-V 根页表, 页表的核心数据结构
	- 