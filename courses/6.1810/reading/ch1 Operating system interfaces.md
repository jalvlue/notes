# overview
os 的作用
1. 让多个应用程序共享硬件资源, 同时运行
2. 在硬件的服务基础之上为应用服务提供更多支持
3. 管理和抽象低级硬件
4. 为应用程序提供可控的交互方式

os 通过一组接口向应用程序提供服务
因此设计接口很重要, 关键是设计出少数几种机制, 让这些机制结合起来提供更多的通用性

xv6 的接口就建立在一组优秀, 紧凑, 合作优良的机制上, 提供了很多的通用性

![[Pasted image 20240331000224.png]]
xv6 只有一个内核, 用来运行程序
运行中的程序称为 `进程`, 每个进程拥有自己的内存空间来存储 `指令, 数据, 栈` 

进程只能访问自己内存空间内的数据, 因此有其他需求时(比如在文件系统写入一个文件...), 那么进程就通过调用内核接口(系统调用), 来将程序运行控制权转移到内核, 并由内核提供自己内存空间外的操作, 完成后返回到进程继续执行
这时就发生了用户态和内核态之间的转换

内核提供的系统调用集合就是应用程序看到的 os 接口
xv6 提供了一部分 unix 接口:
![[Pasted image 20240331001621.png]]
![[Pasted image 20240331110025.png]]


# 1.1 Processes and memory
xv6 进程包括用户空间内存和内核私有的进程状态(内核拥有每个进程的状态)
xv6 使用时分系统进行进程运行调度, 一个进程失去 CPU 时, xv6 会保存进程的寄存器, 在进程下一次被调度运行后, 恢复进程的寄存器状态
内核使用 `PID` 进程标识符来识别每一个进程

### fork, wait, exit
进程可以使用 `fork()` 系统调用创建子进程, 子进程拥有父进程的内存空间副本(指令, 数据)
`fork()` 在父子进程中都会返回, 在父进程中返回子进程的 PID, 在子进程中返回 0

`fork(), wait(), exit()` 代码示例
![[Pasted image 20240331103404.png]]

`exit(int status)` 将会退出进程并释放所有资源(内存, 打开的文件), 并返回状态码
`wait(int *status)` 将会等待子进程的退出, 返回值是子进程的 PID, 然后将子进程返回的状态码赋值到 `int *status` 指针中, 如果不关心子进程返回的状态码, 直接传递零指针(就像上面代码一样)

### exec
调用者使用 `exec()` 从文件系统中指定一个文件取代自己去执行(通常是指定一个可执行文件)
调用者的内存空间将会被指定文件的取代

这样的指定文件必须要有特定的格式来说明文件中哪些是指令, 哪些是数据
xv6 中, 使用 `ELF` 文件格式进行指定(`exec()` 调用的文件通常是编译后的可执行文件)

`exec()` 不会返回, 一旦成功, 调用者将会被取代(内存, 调度权)而不会再运行
一旦失败, 调用者则会继续执行它的代码

代码示例
![[Pasted image 20240331104529.png]]

user/shell.c 例子
![[Pasted image 20240331194903.png]]


# 1.2 I/O and File descriptors
文件描述符是一个 `int`, 代表了内核管理的对象: 可能是进程打开的文件, 目录, 设备, 管道操作等
文件描述符将这些东西都抽象成了字节流

内核在每个进程中维护一个表, 表示这个进程获得了哪些文件描述符

传统上, 文件描述符从 0 开始, `0-stdin`, `1-stdout`, `2-stderr` (上面 shell 的例子中, 打开 `console` 这个文件后检查了是否获得上述三个文件描述, 然后再提供 shell 服务)

### read, write
`read(fd, buf, n), write(fd, buf, n)` 系统调用提供了向文件描述符 fd 读出/写入 buf 的服务, 二者对于某个 fd 都有一个 `offset`, 每次进行调用都会从这个 `offset` 开始, 调用后更新 `offset`

user/cat.c
![[Pasted image 20240331200259.png]]


### open, close
`open()` 将占用进程的一个最小可用文件描述符
`close()` 将释放文件描述符, 以供未来的 `open()` 使用

`fork()` 会复制父进程的内存和文件描述符表
`exec()` 会覆盖父进程内存, 但是保留文件描述符表

fork+exec+open 简单实现 IO 重定向例子
![[Pasted image 20240331201339.png]]
这里子进程 fork 之后释放了 `0-stdin`, 然后马上打开 `0-input.txt`
然后调用 exec, 程序内存替换成 cat, 但文件描述符表不变, `cat(0)` 将 `input.txt` 中的内容输出到 `1-stdout` 中, 简单实现 IO 重定向
fork 子进程, 在子进程中做 IO 重定向

![[Pasted image 20240331202445.png]]
`open()` 权限, 按位表示

fork 虽然复制文件标识符表, 但是父子进程实际共享底层 `offset`
![[Pasted image 20240331203032.png]]
在这个例子中, 子进程先向 `fd=1` 写了一个 `"hello "`, 然后父进程写了 `"world\n"`, 如果父子进程不是共享 `offset`, world 将会覆盖 hello, 但是他们底层是共享 `offset` 的, 因此打印出完整的 `"hello world\n"`

### dup
![[Pasted image 20240331203702.png]]
`dup()` 返回一个执行同一个文件的新文件描述符, 两个文件描述符共享底层 `offset`

### 总结
文件描述符是很强有力的抽象, 他将文件, 设备, 控制台, 管道都抽象成一类东西, 调用者只需要知道使用的文件描述符是什么, 而不需要关系其他的东西

# 1.3 Pipes
管道是一个小的内核 buffer, 以一对文件描述符的形式暴露给进程,
一个用于写, 一个用于读

类似于 `golang channel`
写进程可以将数据写进写管道, 而另外一个读进程可以从管道中读出写进程刚刚写的数据, 提供了一种进程间通信方式

`pipe(int p[])` 创建一个管道, 将读文件描述符放进 `p[0]`, 写文件描述符放进 `p[1]`
![[Pasted image 20240331204649.png]]
这个程序中, 创建了管道, 父进程向管道中写东西, 子进程复制读管道文件描述符, 然后对这个读管道描述符做 `wc`
实现了父进程和子进程之间的通信

shell 中的管道很大程度上就是基于 `pipe()` 系统调用实现的
`echo hello world | wc`


# 1.4 File system
文件系统将数据文件(字节数组), 目录(对其他目录, 数据文件的引用)按照树形结构组织起来, 构成了 os 文件系统

### chdir, mkdir, mknod
`chdir()` 系统调用提供了更改当前所在目录的服务
![[Pasted image 20240331210120.png]]

`mkdir()` 系统调用创建一个新目录
`mknod()` 系统调用创建一个新设备
![[Pasted image 20240331210323.png]]

文件名和文件本身是不同的, 一个文件可以有多个文件名(称为链接)

### fstat
`int fstat(int fd, struct stat*)` 系统调用根据文件的描述符, 获取底层文件本身的信息, 存储在 `stat` 结构中
![[Pasted image 20240331210821.png]]

### link, unlink
`int link(const char *, const char *)` 系统调用根据已有的链接(文件名)创建一个指向相同底层数据的另一个名称
![[Pasted image 20240331211005.png]]

`int unlink(const char *)` 则删除一个已有链接(文件名), 如果是唯一指向底层数据的链接, 那么底层数据将被删除

### 总结
shell 中的用户层程序 `mkdir, ln, rm, cd` 就是使用上述系统调用构建的

# 1.5 Real world
文件系统和文件描述符是最强大的抽象
