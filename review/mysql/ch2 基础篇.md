# 一个 select 语句的全过程

一个执行流程 overview
![[Pasted image 20240425160206.png]]
可以看出, mysql 服务端可以分成
- Server 层, 建立连接、分析、执行 SQL 
- 存储层, 负责数据的存储和提取(InnoDB 是 mysql 的默认存储引擎)

### 1 连接器
连接器就是 mysql 客户端连接到服务端的组件, mysql 的连接是基于 tcp 的, 需要握手挥手

在这里, 服务端会记录客户端的用户和权限, 后续客户端的任何操作都会基于这个权限

所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

连接命令:
`mysql -h $ip -u $user -p`
- -h 指定服务端地址
- -u 指定连接用户
- -p 指定密码(可直接打在命令行中, 可以后续交互输入)

使用 `show processlist` 命令可以查询服务端有多少个连接


### 2 查询缓存
对于查询语句(select), mysql 会以 KV 的形式保存 `query-result` 在缓存中, 每次有查询语句过来, 就先找下有没有缓存过, 

对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。

所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。

### 3 解析 SQL
解析器会对 sql 语句进行解析

- 词法解析, 解析出 token 和 keyword 
- 语法分析, 构建语法树
![[Pasted image 20240425161953.png]]


### 4 执行 sql
- prepare 阶段，也就是预处理阶段；
- optimize 阶段，也就是优化阶段；
- execute 阶段，也就是执行阶段；

预处理器
- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

优化器
为 sql 语句制定执行计划, 比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
TODO: 覆盖索引, 

执行器
执行器会与存储引擎进行交互, 交互以记录为单位

三种执行方式:
- 主键索引查询
- 全表扫描
- 索引下推

TODO: 执行器与 InnoDB 引擎交互过程


# 一行记录的存储
mysql 的每一个数据库都会有自己的目录, 数据库中的表则会以文件的形式放在该目录下

例如, 有一个数据库 `my_test`, 数据库内有一个表 `t_order`, 
```bash
[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```
- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，t_order 的**表结构**会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- t_order.ibd，t_order 的**表数据**会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

### 表空间结构
InnoDB 中, 大概结构:
![[Pasted image 20240425165950.png]]
- 行, 行是记录的单位, 每一个记录都在一个行内
- 页, 页是 InnoDB 读写的单位, 类似 CPU 缓存, 每次读写时都会以页为单位将许多行记录同时从磁盘中加载到内存中, **默认每个页的大小为 16 KB**
- 