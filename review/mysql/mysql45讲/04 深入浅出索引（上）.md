- 索引就是为了提高数据查询的效率的, 就像书的目录一样


# 索引的常见模型
- 索引是一种广义上的 `ADT`, 有很多的实现方式, 主要是:
	- 哈希表
	- 有序数组
	- 搜索树

### 哈希索引
- 哈希就 `kv` 存储, 查桶很快, 但是进入到桶里之后, 元素是无序的 (逻辑上很靠近的记录在物理上可能存储在不同的哈希桶里)
- 因此哈希索引对于区间范围查询的效果一般
- ![[Pasted image 20240908181208.png]]
- 所以哈希索引实际上不适合关系型数据库, 比较适合只有等值查询的场景, 比如 `mencached` 或其他 `nosql`

### 有序数组索引
- 有序数组在等值查询和范围查询场景中的性能就都非常优秀, 二分很快
- ![[Pasted image 20240908181355.png]]
- 但是有序数组存储的插入很垃圾, 需要移动该记录之后的所有记录, 因此适用于静态数据存储


### 搜索树索引
- 一般使用 `b+ tree` 来作为索引
	- 数据存储在叶子节点中, 有序
	- 自平衡
	- 多叉, 树高很优秀, 一个节点存储一个数据页, 因此拿一个数据页只需要几次的读磁盘, 如果 `buffer pool` 已经有某些页面的缓存 (中间页访问是比较频繁的, 很可能出现在内存的缓存中), 那么查询将更快
- 有这些数据库亲和优质特性 `b+ tree` 通常是数据库存储引擎的选择


### 其他结构索引
- 跳表
- LSM 树
- ...


# InnoDB 的索引模型
- `innodb` 是使用最广的 `mysql` 引擎, 使用的是 `b+ tree` 索引
- 每一个索引在 `innodb` 中对应着一颗 `b+ tree`

```sql
create table T  
(  
    id   int primary key,  
    k    int not null,  
    name varchar(16),  
    index (k)  
) engine = InnoDB;
```
- 建立了有两个索引的表, 这个表在 `innodb` 中有两颗 `b+ tree`
	- 主键索引: 树的叶子节点存储的是整行数据, 也称为聚簇索引
	- 非主键索引 (k): 树的叶子节点存储的是该记录对应的主键的值, 也成为二级索引
- ![[Pasted image 20240908182512.png]]
- 主键索引与非主键索引的区别:
	- `select * from T where ID=500`, 按照主键进行查询, 直接搜主键那颗 `b+ tree`
	- `select * from T where k=5`, 按照 k 索引进行查询, 首先查询 k 索引对应的 `b+ tree`, 拿到该记录的主键 ID, 然后利用这个主键 ID, 到主键 `b+ tree` 去搜完整记录, 搜了两个 `b+ tree`, 这个过程称为回表
	- 也就是说, 如果没有索引覆盖的话, 非主键索引会多搜一次索引树, 因此尽量使用主键查询


# 索引维护
- 有收获就会有代价, 对于 `b+ tree`, 代价就是在插入新数据时, 为了维护索引的有序性, 需要做一些额外处理 (其实就是 `b+ tree` 的自平衡过程[[lec17 B-Trees (2-3, 2-3-4 Trees)]])
- 对于主键索引, 一般都设置为 `NOT NULL PRIMARY KEY AUTO_INCREMENT`, 自增的, 每次新插入记录都会自动自增
- 同时自增主键的存储空间表现也比较优秀, 因此使用自增主键是比较合理的
- 使用业务字段直接做主键的场景: (KV 场景)
	1. 只有一个索引
	2. 该索引是唯一索引

# question
对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：
```sql
alter table T drop index k;
alter table T add index(k);
```
如果你要重建主键索引，也可以这么写：
```sql
alter table T drop primary key;
alter table T add primary key(id);
```
我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？

- 索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
- 重建索引合理, 可以省空间
- 重建主键索引不合理, 可以使用 `alter table T engine=InnoDB`
