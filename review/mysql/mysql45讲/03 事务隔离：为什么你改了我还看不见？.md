- 事务: 保证多个操作的原子性
- `mysql` 中, 事务是在存储引擎层实现的
	- `innodb` 支持事务
	- `MyISAM` 不支持事务所以被取代了


# 隔离性与隔离级别
- 事务的特征: ACID
	- `A, atomicity`: 原子性
	- `C, consistency`: 一致性, 事务执行的结果必须使数据库从一个一致状态转变为另一个一致状态, 事务在开始之前和结束之后, 数据库必须满足所有的完整性约束条件, 以保证数据的一致性 [[事务的ACID#一致性]]
	- `I, isolation`: 隔离性, 多个事务并发执行时, 每个事务都应该感觉不到其他事务的存在, 每个事务的操作都应该与其他事务的操作相互隔离, 以防止数据的相互干扰, 事务应该具有隔离级别, 如读未提交、读已提交、可重复读和串行化, 以控制事务之间的相互影响
	- `D, durability`: 持久性
- 这里重点关注事务的隔离性 [[事务的隔离性]]
- 事务并发带来的问题
	- 脏读 `dirty read`
	- 不可重复读 `non-repeatable read`
	- 幻读 `phantom read`
- 为了解决上述问题, 为事务引入隔离级别的概念, 隔离级别越高, 效率越低
	- 读未提交 `read uncommitted`: 没提交修改对于其他事务就是可见的
	- 读提交 `read committed`: 提交了修改对于其他事务才可见
	- 可重复读 `repeatable read`: 一个事务执行过程中看到的数据总是在事务启动时看到的是一致的 (也就是不管在该事务期间, 外面发生了什么, 都不会影响到该事务)
	- 串行化 `serializable`: 对于同一行记录, 读加读锁, 写加写锁, 锁冲突时, 后面访问的事务必须等上一个事务完成, 将锁释放
	- ![[Pasted image 20240908172614.png]]
- MVCC: 视图+锁, 这套隔离级别的实现方式
	- 读未提交: 不使用 MVCC 和视图和锁, 直接返回当写的最新数据值
	- 读提交: 在每一个 sql 开始执行的时候都生成一个视图
	- 可重复读: 在事务开始的时候生成一个视图, 后续的所有的 sql 都基于该视图
	- 串行化: 直接加锁来避免并发访问
- 隔离级别是可以修改的, `mysql-8.3` 的默认隔离级别似乎是可重复读 ![[Pasted image 20240908173552.png]]
- 每个隔离级别都有权衡, 具体用途得看场景

# 事务隔离的实现
- `MVCC` 是基于视图的, 而实现视图的核心就是 `redo-log`
- 假设一个值按顺序被更改 ![[Pasted image 20240908173945.png]]
- 则不同时间启动的事务会有不同的 `read-view`, 从而对于该记录会读到不同的值
- `MVCC, multi-version concurrent control` 多版本并发控制, 这里的多版本指的就是 `redo-log` 中的记录的版本以及对应的 `read-view`
- `redo-log` 不会一致保留, 因此 `mysql-daemon` 会维护这些信息, 直到没有事务用到这些 `redo-log` 时, 他们就会被同步到磁盘, 然后从 `redo-log` 中剔除
- 从而, 很显然, 尽量不要使用长事务, 因为这样会导致对 `redo-log` 的引用非常久远, 让 `daemon` 无法清除 `redo-log`, 占用大量存储空间

```ad-note
在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库
```

# 事务的启动方式
- 显式启动事务语句: `begin, start transaction + commit, rollback`
- `set autocommit=0`: 将线程的自动提交关闭, 事务会持续存在, 直到手动执行 `commit, rollback` 或者线程的连接断开
- 因此建议是使用 `set autocommit=1`, 并显式使用 `begin + commit` 处理事务
- 为了避免多次 `begin` 的麻烦, 可以使用 `commit work and chain`, 将当前的事务提交, 然后自动开启一个新的事务


# question
```ad-question
:> 你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？

:> 
开发端: 确认使用 set autocommit=1, 将不必要的只读事务去掉
数据库端: 监控长事务 information_schame.Innodb_trx, 对长事务进行报警, 如果使用的是 MySQL 5.6 或者更新版本, 把 innodb_undo_tablespaces 设置成 2（或更大的值）, 如果真的出现大事务导致回滚段过大, 这样设置后清理起来更方便
```
