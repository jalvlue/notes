- 索引: 数据的目录, 由存储引擎 (InnoDB)建立维护
	- 数据结构分类: B+tree 索引, Hash 索引, Full-text 索引
	- 物理存储分类: 聚簇索引 (主键索引), 二级索引 (辅助索引)
	- 字段特性分类: 主键索引, 唯一索引, 普通索引, 前缀索引
	- 字段个数分类: 单列索引, 联合索引
- 创建表时 InnoDB(默认为 B+tree 索引) 的索引选择
	- 有主键, 主键作为聚簇索引的 key
	- 没有主键, 选择第一个不包含 `null` 的 `unique` 列作为聚簇索引的 key
	- 上述均无, InnoDB 将生成一个隐式自增 id 列作为聚簇索引的 key
- 主键索引的 B+tree 叶子节点中存放的是实际数据
- 二级索引的 B+tree 叶子节点存放的是主键值
- 使用二级索引查询的过程(没有覆盖索引时)
	- 通过二级索引找到对应的叶子节点, 获取记录的主键值
	- 通过主键索引获取整行数据(回表)
	- 此时查了两个 B+tree
- ![[Pasted image 20240520172732.png]]
- B+tree 的优点
	- vs B-tree
	- vs BST
	- vs hash
- 联合索引
- ![[Pasted image 20240520172841.png]]
- 联合索引存在最左匹配原则, 索引元素按顺序依次排序, 不满足最左匹配则索引失效
- ![[Pasted image 20240520173148.png]]
- 联合索引范围查询: 
	- **范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。
	- 例如: `select * from t_table where a > 1 and b = 2`, **在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的**
	- `>=, <=, BETWEEN, like` 等前缀匹配的范围查询是不会停止匹配的, 此时拿到第一个字段的第一个值后, 就可用第二个字段的索引再缩小遍历范围
- 索引下推
	- `select * from t_table where a > 1 and b = 2`
	- 只有 `a` 可以使用到联合索引, 在之前的版本中, 就此开始一个个回表, 到主键索引上找出数据行后再对比 `b` 字段
	- 索引下推就是再联合索引遍历过程中, 对联合索引包含的字段先做判断, 直接过滤掉不满足条件的记录, 减少回表次数
- 索引区分度: 建立联合索引时, 把区分度大的字段排在前面
- ![[Pasted image 20240520192444.png]]
- 索引适合场景
	- 字段具有唯一限制 `unique`
	- 经常使用 `where` 查询条件的字段, 如果查询的不止一个字段, 可以建立联合索引
	- 经常使用 `group by` 和 `order by` 的字段, 这样在查询过程中就不需要做依次排序 (filesort), 查出来的就是有序的
- 索引不适合的场景
	- `where, group by, order by` 用不到的字段
	- 字段中存在大量重复数据的字段 (性别等), mysql 对于某个值在表的数据行中出现比率很高的时候会忽略索引, 进行全表扫描
	- 表数据太少
	- 频繁修改的字段不要使用索引
- 优化索引
	- 前缀索引优化: TODO
	- 覆盖索引优化: 建立联合索引, 直接在索引上就覆盖了查询结果, 避免回表
	- 主键索引最好是自增的: 追加而不是插入, 主键字段最好不要太长, 二级索引叶子节点存的就是主键数据
	- 索引字段最好是 `not null`
	- 防止索引失效
		- 模糊匹配: `like %xx, like %xx%`
		- 对索引字段进行计算、函数、类型转换
		- 联合索引不遵循最左匹配原则
		- `where` 子句中, `or` 前是索引列, 后不是, 会造成索引失效
- 扫描执行类型
	- All
	- index
	- range
	- ref
	- eq_ref
	- const
- ![[Pasted image 20240520195214.png]]
- 
