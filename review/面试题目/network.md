### osi 7 层模型

### tcp/ip 四层模型
- 应用层: `http, tftp, ftp, smtp, telnet, dns`
- 传输层: `tcp, udp`
- 网络层: `ip, icmp, arp`
- 数据链路层: `ppp, Ethernet`


### tcp 头部
- 源/目的端口
- 序列号
- 确认号
- 校验和 (CRC 算法)
- 16-bit 的窗口, 用来告诉对方自己的缓冲区还能容纳多少字节
- 数据部分
- ...


### tcp 如何保证可靠传输
- 校验和
- seq/ack 确认数据已经被对方收到了
- 超时重传
- 流量控制(窗口)
- 快速重传 (接收到冗余的 ack )
- 拥塞控制 (慢启动算法、避免拥塞算法)


### tcp 三次握手
![[Pasted image 20240511214504.png]]
注意报文中的确认号 ack 和 bit ACK

1. 客户端发起, syn 置为 1, 设置一个客户端的 seq
2. 服务器接收到请求, 给出回复: syn 置为 1, ack 为客服端 seq+1, 表示已经收到这个客户端消息了, 同时自己确定一个服务端 seq
3. 客户端收到服务器的回复, ack 置为 1, 发送自己下一个序列的数据, 同时

### 为什么需要三次握手
只有三次握手才能证明服务端和客户端的收发能力都是正常的。

第一次握手：客户端发数据服务端接收，服务端可以知道客户端发消息的能力是正常的，自己接收消息的能力是正常的。

第二次握手：服务端发消息客户端收，客户端可以知道自己发送接收消息的能力和服务端发送接收消息的能力是正常的。

第三次握手：客户端再发送消息服务端接收，服务端可以知道自己发送消息的能力是正常的，客户端接收消息的能力是正常的。


### ===四次挥手===
TODO

![[Pasted image 20240511215045.png]]
客户端和服务器都可以发起挥手

**第一次挥手**
客户端发送释放报文，并停止发送数据，将首部的FIN标识位置为1，序列号seq=u发送给服务器，值等于前面已经传送过来的数据的最后一个字节的序号加1，此时客户端进入**FIN_WAIT_1**状态。即便FIN报文不携带数据，也要消耗一个序列号。

**第二次挥手**
服务器在收到释放报文后，发送确认报文，ACK标识位置为1，ack值为客户端发送的序列号u+1，并带上自己的序列号v，然后服务器进入**CLOSE_WAIT关闭等待**状态。这时服务器TCP通知高级应用进程，客户端向服务器的连接释放了，进入半关闭状态，但是服务器如果向客户端发送数据，客户端仍然可以接收，这个状态要持续一段时间，也就是**CLOSE_WAIT关闭等待**持续的时间。

客户端收到服务器的确认请求后，进入**FIN_WAIT_2**状态，等待服务器发送释放报文。

**第三次挥手**
服务器数据处理完毕后，向客户端发送释放连接报文，FIN标识位置为1，ack的值为客户端的序列号u+1，由于在半关闭状态，服务器很可能又发送一些数据，假定此时序列号为w，服务器进入**LAST_ACK**状态，等待客户端确认。

**第四次挥手**
客户端在收到服务器的释放连接报文后，会发送确认报文，ACK标识位置为1，ack值为服务器发送的序列号w+1，

自己的序列号是u+1，然后客户端就进入**TIME_WAIT**状态。此时TCP连接还没有释放，必须经过两个MSL时间（一个MSL指的是报文段最长寿命），当客户端撤销TCB，才进入**CLOSED**状态。

服务器只要收到客户端发送的确认请求，立即进入**CLOSED**状态。同时会撤销 TCB，TCP 连接至此结束。


### 什么时 SYN 攻击, 如何避免
就是发送很多 SYN 包来尝试连接从而消耗资源

SYN 攻击是指利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。

如果向某个服务器端口发送大量的 SYN 报文，接收到客户端发来的 SYN 报文之后，服务端就需要为每个请求分配一个进程控制块 TCB，并返回一个 SYN-ACK 报文，并立即转为 SYN_RECV 半开连接状态，收不到对端 ACK 回复的服务端还会重传 SYN-ACK 报文, 系统会为此耗尽资源


### tcp 和 udp 的区别
- 连接有无
- 可靠性
- 性能
- 首部开销 20 vs 8
- 流式 vs 包
- 使用场景

### dns 流程
- 本机 -> 本地 dns 服务器
- 本地 dns 服务器查缓存
- 本地 dns 服务器 -> 根域名服务器(索要顶级域名ip)
- 本地 dns 服务器 -> 顶级域名服务器 (索要授权域名服务器)
- 本地...
- 找到, 返回给本机并写入缓存中

.—- .com —– [qq.comopen in new window](http://qq.com/) —– www.qq.com –ip 给客户机。


### 浏览器输入 url 到显示器显示的全过程
1. Url 解析: 本地缓存(浏览器, 操作系统) -> dns 服务 -> 获得 url 的 ip
2. tcp 连接: 调用 socket 函数简历 tcp 连接
3. http 请求: 浏览器想服务器发起一个 http 请求, 按照 http 协议生成报文
4. 通过连接发送这个请求报文
5. 服务器接收并响应, 返回 http response 报文
6. 浏览器接收响应, 渲染页面

### ping 指令
Ping 是一种常用的网络工具，用于测试主机之间的连通性和测量往返时间（Round-Trip Time，RTT）。下面是 Ping 指令执行的一般过程：

1. **构造 Ping 请求数据包**：Ping 指令首先构造一个 ICMP（Internet Control Message Protocol）的 Echo Request（回显请求）数据包。该数据包包含一个唯一的标识符和序列号，以及一段数据（通常是一些无意义的数据）。

2. **发送 ICMP Echo Request**：Ping 指令将构造好的 ICMP Echo Request 数据包发送给目标主机。通常情况下，Ping 使用 ICMP 协议发送数据包，但也可以使用其他协议，如 UDP 或 TCP。

3. **等待回应**：一旦目标主机接收到 ICMP Echo Request 数据包，它会生成一个 ICMP Echo Reply（回显应答）数据包，并将其发送回源主机。

4. **接收 ICMP Echo Reply**：源主机接收到目标主机发送的 ICMP Echo Reply 数据包后，检查标识符和序列号是否匹配，以确定这是对应该发送的 Echo Request 的回应。

5. **计算往返时间**：源主机记录接收到回应的时间，并计算往返时间（RTT），即从发送 Echo Request 到接收 Echo Reply 的时间。

6. **显示结果**：Ping 指令将显示往返时间和其他统计信息，如丢包率、最小/最大/平均往返时间等。

需要注意的是，Ping 指令在不同操作系统和网络环境下可能会有细微的差异，但上述步骤概括了一般的执行过程。


ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因、改善网络设置等。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，具体的原因将由 ICMP 通知。


### http 的 GET 和 POST 方法的区别
- GET 用于获取资源, POST 用于更新资源
- GET 是幂等的
- GET 的请求数据会依附在 url 上, 也就是请求的数据是在 http 报文中写明的
- POST 的数据将会被包装在请求体内, 更安全


### GET 可以带 body 吗

RFC 规范并没有规定 GET 请求不能带 body 的。任何请求都可以带 body 的。 GET 请求是获取资源，所以根据这个语义不需要用到 body。URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。


### TCP 和 UDP 的区别

TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是互联网协议套件中的两个主要传输层协议，它们在数据传输方式和应用场景上有显著区别。以下是它们的主要区别和各自的应用场景：

#### TCP 的特点
1. **面向连接**：
   - 在传输数据之前，必须先建立连接（三次握手）。
   
2. **可靠传输**：
   - 提供可靠的数据传输，确保数据包按顺序到达且无丢失（通过确认应答、重传和序列号）。

3. **流量控制**：
   - 通过滑动窗口机制实现流量控制，避免网络拥塞。

4. **拥塞控制**：
   - 通过算法（如慢启动、拥塞避免、快重传和快恢复）来控制网络拥塞。

5. **数据传输有序**：
   - 确保数据包按发送顺序到达目的地。

6. **开销较大**：
   - 由于需要维护连接状态和进行各种控制，TCP 的开销相对较大。

#### UDP 的特点
1. **无连接**：
   - 发送数据前不需要建立连接，直接发送数据包。

2. **不保证可靠性**：
   - 不提供数据包的确认、重传和序列号，可能导致数据包丢失或乱序。

3. **无流量控制和拥塞控制**：
   - 不进行流量控制和拥塞控制，适合要求低延迟的应用。

4. **数据传输无序**：
   - 数据包可能乱序到达，应用程序需要自己处理数据包的顺序。

5. **开销较小**：
   - 由于不需要维护连接状态和进行复杂控制，UDP 的开销较小。

### 应用场景

#### TCP 的应用场景
TCP 适用于需要可靠传输、数据完整性和顺序的应用场景，如：
- **网页浏览（HTTP/HTTPS）**
- **文件传输（FTP、SFTP）**
- **电子邮件（SMTP、IMAP、POP 3）**
- **远程登录（SSH、Telnet）**
- **数据库连接（SQL、NoSQL 数据库）**

#### UDP 的应用场景
UDP 适用于对传输实时性要求高且可以容忍部分丢包的应用场景，如：
- **视频流传输（YouTube、Netflix）**
- **音频流传输（VoIP、在线音乐）**
- **在线游戏**
- **实时通信（视频会议、语音聊天）**
- **网络广播和多播**

### 五层网络模型的特点

五层网络模型（从上到下）包括应用层、传输层、网络层、数据链路层和物理层。各层的主要特点如下：

1. **应用层**：
   - **功能**：提供网络服务和应用程序直接交互的接口。
   - **协议**：HTTP、HTTPS、FTP、SMTP、DNS 等。
   - **特点**：处理特定应用的数据格式和通信控制。

2. **传输层**：
   - **功能**：提供端到端的通信服务，包括数据分段、传输、重组、流量控制和错误检测。
   - **协议**：TCP、UDP。
   - **特点**：确保数据可靠传输（TCP）或快速传输但不保证可靠性（UDP）。

3. **网络层**：
   - **功能**：负责数据包的路由和转发，实现不同主机间的通信。
   - **协议**：IP（IPv 4、IPv 6）、ICMP、ARP。
   - **特点**：处理数据包的寻址和路由选择。

4. **数据链路层**：
   - **功能**：负责数据帧的传输和错误检测，确保数据在相邻节点间的可靠传输。
   - **协议**：以太网、Wi-Fi（802.11）、PPP。
   - **特点**：处理 MAC 地址、帧同步、流量控制和错误检测。

5. **物理层**：
   - **功能**：负责比特流的传输，定义硬件设备的电气、机械、功能和规程特性。
   - **协议**：具体的标准如 RJ 45、光纤、无线电频率。
   - **特点**：处理物理介质上的数据传输，包括电压、电缆、接头、无线信号等。

### 总结

- **TCP** 提供可靠、顺序