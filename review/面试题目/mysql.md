# 索引
### 索引分类
- 数据结构: B+ tree, hash, full-text
- 物理存储: 聚簇索引 (主键索引), 二级索引 (辅助索引)
- 字段特性: 主键索引, 唯一索引, 普通索引, 前缀索引
- 字段个数: 单列索引, 联合索引

![[Pasted image 20240512154815.png]]

主键索引存放着真实的数据
![[Pasted image 20240512161741.png]]

二级索引存放的是对应记录的主键
![[Pasted image 20240512161817.png]]

因此一般的通过二级索引的查询需要经过两次 B+树查询:
1. 通过二级索引获得主键
2. 通过主键索引获得记录, 这个过程叫做回表


不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：
```sql
select id from product where product_no = '0002';
```
**这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据**。


###### 联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

比如，将商品表中的 product_no 和 name 字段组合成联合索引`(product_no, name)`，创建联合索引的方式如下：

```sql
CREATE INDEX index_product_no_name ON product(product_no, name);
```

![[Pasted image 20240512162419.png]]
可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。

也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。

因此，使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

上面这些查询条件之所以会失效，是因为 `(a, b, c)` 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，**b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

###### 索引下推

现在我们知道，对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
    
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。
    

当你的查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。


### 索引不适合哪些场景
- 数据量少的
- 更新频繁的
- 区分度低的 (例如性别)

### 索引适用场景
- 字段有唯一性限制的，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的



### 索引潜规则

# 事务
### 事务有哪些特性
- 原子性
- 一致性
- 隔离性
- 持久性

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

### 并发事务的问题
![[Pasted image 20240512165129.png]]
[[事务的隔离性]]
![[Pasted image 20240512165143.png]]


- 脏读: 一个事务读到了另一个事务未提交修改过的数据, 由于未提交, 随时可能回滚, 因此很可能读到的是无用的 `脏数据` 
- 不可重复读: 一个事务内两次读取一个数据, 由于其他事务在中间并发修改, 导致前后两次读取到的值不同
- 幻读: 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了

![[Pasted image 20240512165119.png]]


# 面试题

### InnoDB 与 MyISAM 的区别
- InnoDB 支持事务，MyISAM 不支持事务
- InnoDB 支持外键，MyISAM 不支持外键
- InnoDB 将数据文件和索引文件放在一起, MyISAM 分开成两个文件存放
- InnoDB 支持 MVCC (多版本并发控制)，MyISAM 不支持

### 聚簇索引和非聚簇索引的区别, 优缺点
- 聚簇索引是物理结构, 只有一个
- 聚簇索引上的叶子节点存放实际数据, 其他非聚簇索引叶子节点上存放的是主键值 (聚簇依据)
- 聚簇索引的插入速度严重依赖插入顺序

### 索引失效
- 模糊匹配: `like %xxx, like %xxx%`
- 对索引字段使用函数
- 对索引字段进行计算
- 不符合最左匹配原则, 联合索引失效
- `where or` 有一个字段不是索引列

### B+tree vs BST, RHT, B-tree
- BST, RHT 树高, 磁盘 IO 次数多
- B+tree 只有叶子节点存放数据, 节点利用率高, 节点个数少
- B+tree 使用双向链表将记录按顺序串联起来, 范围查找更加高效




### Mvcc 熟悉吗它的底层原理
MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。

MVCC需要关注这几个知识点：
- 事务版本号
- 表的隐藏列
- undo log
- read view


### 一条 sql 执行过长的时间你如何优化从哪些方面入手
- 主从分离, 读写分离
- 查看是否涉及多表和多子查询, 优化 sql 结构
- 加索引
- 分表
- explain, 查看执行计划


### Blob 和 text 有什么区别
- Blob 用于存储二进制数据，而 Text 用于存储大字符串。
- Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。
- Text 值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。


### 数据库三大范式
- 第一范式：数据表中的每一列（每个字段）都不可以再拆分。
- 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
- 第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。

