## 什么是 Redis？它主要用来什么的
`remote dictionary server`
支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。

- 数据存在内存中, 访问很快, 广泛用于缓存
- 分布式事务
- Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。

## 说说 Redis 的基本数据结构类型
- String（字符串）
- Hash（哈希）
- List（列表）
- Set（集合）
- Zset（有序集合）

![[Pasted image 20240513143848.png]]

###### List
![[Pasted image 20240513144133.png]]
- lpush+lpop=Stack（栈）
- lpush+rpop=Queue（队列）
- lpsh+ltrim=Capped Collection（有限集合）
- lpush+brpop=Message Queue（消息队列）


###### 三种特殊数据类型
- Geo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。
- HyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。
- Bitmaps ：用一个比特位来映射某个元素的状态，在 Redis 中，它的底层是基于字符串类型实现的，可以把 bitmaps 成作一个以比特位为单位的数组



## redis 为什么快
- 内存
- 高效的数据结构: 动态字符串, 哈希表, 双端链表, 跳表
- 单线程模型
- io 多路复用

## 缓存击穿, 缓存穿透, 缓存雪崩

**缓存穿透**：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。

- 参数校验
- 数据库查询为空时设置为空值 (默认值, 下次就能打到缓存上了)
- 布隆过滤器


**缓存雪奔：** 指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。

- 缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒酱紫。
- Redis 故障宕机也可能引起缓存雪奔。这就需要构造Redis高可用集群啦。


**缓存击穿：** 指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。
- **1.使用互斥锁方案**。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如(Redis 的 setnx）去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。
- **2. “永不过期”**，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。


## redis 过期策略
#### 惰性过期

> 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

#### 定期过期

> 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
> 
> Expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。


## redis 内存淘汰策略
- volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中使用 LRU（最近最少使用）算法进行淘汰；
- allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
- volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
- allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；
- volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。
- allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；
- noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。


## redis 使用场景
- 缓存
- 排行榜
- 分布式锁
- 消息队列

## redis 持久化方案
![[Pasted image 20240513145735.png]]

- RDB: redis database file, 每隔一段时间做 snapshot 
- AOF: append only file, 

## redis 高可用
- 主从模式
主从赋值(全量复制, 增量复制), 主节点负责写操作, 从节点负责读操作


- 哨兵模式
由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，并在被监视的主节点进入下线状态时，**自动将下线主服务器属下的某个从节点升级为新的主节点**。但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现问题（**单点问题**），因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。
![[Pasted image 20240513150230.png]]

- 集群模式
实现了 Redis 的**分布式存储**。对数据进行分片，也就是说**每台 Redis 节点上存储不同的内容**，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。
一个 Redis 集群由多个节点组成，**各个节点之间是怎么通信的呢**？通过**Gossip 协议**！

- meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。
- ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。
- pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。
- fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。


## redis 分布式锁
TODO

## redis 的跳表
![[Pasted image 20240513150558.png]]

- 跳跃表是有序集合zset的底层实现之一
- 跳跃表支持平均**O（logN）**,最坏 O（N）复杂度的节点查找，还可以通过顺序性操作批量处理节点。
- 跳跃表实现由**zskiplist和zskiplistNode**两个结构组成，其中zskiplist用于保存跳跃表信息（如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。
- 跳跃表就是在链表的基础上，增加多级索引提升查找效率。


## mysql 与 redis 保证双写一致性
- 缓存延时双删
- 