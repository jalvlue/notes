# 0. 极简面试版
Go 采用的是三色标记法，将内存里的对象分为了三种：
- 白色对象：未被使用的对象；
- 灰色对象：当前对象有引用对象，但是还没有对引用对象继续扫描过；
- 黑色对象，对上面提到的灰色对象的引用对象已经全部扫描过了，下次不用再扫描它了。

当垃圾回收开始时，Go 会把根对象标记为灰色，其他对象标记为白色，然后从根对象遍历搜索，
按照上面的定义去不断的对灰色对象进行扫描标记。当没有灰色对象时，表示所有对象已扫描过，
然后就可以开始清除白色对象了。

# golang 内存模型
- 以空间换时间, 一次缓存多次复用
- 多级缓存, 降低锁的粒度
- 根据缓存大小细分为多级 span, 提高利用率

![[Pasted image 20240511153825.png]]
- mheap：全局的内存起源，访问要加全局锁
- mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内
- mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁

![[Pasted image 20240511154002.png]]


# 3. 内存分配流程
- new
- make
- &T{}

![[Pasted image 20240511154330.png]]
- Tiny
- Small
- Large

# 4. GC
并发三色标记法+混合写屏障机制

### 三色标记法
![[Pasted image 20240511160323.png]]
- 黑: 对象自身存活, 而且其指向的所有对象都已经标记完成
- 灰: 对象自身存活, 其指向的对象还未标记完成
- 白: 对象尚未被标记到, 可能是垃圾

流程:
- 标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰
- 标记规则是，从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑
- 标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫.

### 并发垃圾回收
![[Pasted image 20240511160850.png]]

这里由于 GC 协程和用户协程是并发的, 因此可能会导致漏标问题将一个需要保留的内存删除, 导致程序出现致命问题
也就是 GC 处理完一个对象(A), 之后, 用户协程将 A 引用了另外一个无其他引用的对象(B), 此时由于 A 已经处理完, 因此没有办法将 B 标记为灰, 最终导致 B 被回收
![[Pasted image 20240511163147.png]]

- 多标, 可以通过下一轮 GC 弥补


内存清理产生的碎片可以根据大小或分为 spanClass 放到对应的 central cache 中, 内存组织架构的优点

### 屏障机制
- 强三色不变式: 白色对象不能直接被黑色对象引用(如果出现这种情况, 则出发屏障, 通过回调将白色对象改为灰色对象)
- 弱三色不变式: 白色对象可以直接被黑色对象引用, 但是要从某个灰色对象出发仍然可达该白色对象(黑色引用白色, 则必然需要通过某一路径(通常是来自某灰色对象的引用), 只要保证这个引用一定不会在后续流程中被用户协程并发删除即可)

![[Pasted image 20240511170740.png]]
![[Pasted image 20240511170744.png]]



