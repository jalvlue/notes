# sync.Mutex
### 基本流程
作为锁, 核心就是上锁解锁
- 使用一个内部状态值标识一个锁的状态, 0 标识未加锁, 1 标识已加锁
- 上锁: 0 -> 1
- 解锁: 1 -> 0
- 上锁时若已经为 1, 则上锁失败, 需要原来的持有者解锁之后, 才能重新尝试加锁

### 自旋到阻塞
- 阻塞/唤醒：将当前 goroutine 阻塞挂起，直到锁被释放后，以回调的方式将阻塞 goroutine 重新唤醒，进行锁争夺；
- 自旋 + CAS：基于自旋结合 CAS 的方式，重复校验锁的状态并尝试获取锁，始终把主动权握在手中.

自旋: 乐观锁, 认为可能很快就能拿到锁了, 没必要进行阻塞挂起上下文切换, 
阻塞: 悲观锁

`sync.Mutex` 采用这样的策略:
- 首先保持乐观，goroutine 采用自旋 + CAS 的策略争夺锁；
- 尝试持续受挫达到一定条件后，判定当前过于激烈，则由自旋转为 阻塞/挂起模式.

上面谈及到的由自旋模式转为阻塞模式的具体条件拆解如下：
- 自旋累计达到 4 次仍未取得战果；
- CPU 单核或仅有单个 P 调度器；（此时自旋，其他 goroutine 根本没机会释放锁，自旋纯属空转）；
- 当前 P 的执行队列中仍有待执行的 G. （避免因自旋影响到 GMP 调度效率）


### 正常模式和饥饿模式

在正常模式下, 所有尝试获取锁但是失败的 goroutine 都会先自旋, 然后再阻塞
一旦解锁, 而且阻塞队列不空, 那么解锁者将会唤醒阻塞队列的首节点, 让他开始尝试再次获取锁
这里的问题是: 这个被唤醒的 goroutine 可能会跟很多正在自旋的, 未进入阻塞队列的 goroutine 竞争, 从而陷入饥饿

陷入饥饿的判断标准是: 一个 goroutine 等锁时间超过一个阈值(可设置, 默认为 1ms)
则系统进入饥饿模式, 强行公平调度

在饥饿模式下, 不再有自旋这一步, 所有尝试加锁的 goroutine 全部都直接进入阻塞队列, 进行公平的调度

当阻塞队列已清空，或取得锁的 goroutine 等锁时间已低于 1ms 时，则回到正常模式

