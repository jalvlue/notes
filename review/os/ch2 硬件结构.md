# 冯诺依曼模型
![[Pasted image 20240418134802.png]]
![[Pasted image 20240418134821.png]]

CPU 与存储单元之间通过总线进行数据传输

### 总线
- 地址总线: 用于指定 CPU 将要操作的内存地址
- 数据总线: 用于读写内存的数据
- 控制总线: 用于发送和接收信号, 例如中断、设备复位等信号

线路位宽与 CPU 位宽:
位宽就是并行传输的数据位个数
一般来说线路的位宽和 CPU 位宽是相同的, 

### CPU 执行程序的过程
CPU 执行程序的过程如下：

- 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。
- 第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；
- 第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；

简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。

CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 **CPU 的指令周期**。

### 指令
指令其实就是一堆二进制码, 只是可以写成汇编的速记形式
不同的 CPU 可能使用不同的指令集, 
这里以最简单的 mips 指令集为例:
![[Pasted image 20240418140026.png]]

指令分为 3 中类型, 由前 6 位操作码界定
例如 `add R0 R1 R2` 指令,
将寄存器 0 和寄存器 1 中的值相加后存入到寄存器 2 中

这个 add 指令属于 R 类指令, 具体如下:
![[Pasted image 20240418140247.png]]
- add 对应的 MIPS 指令里操作码是 `000000`，以及最末尾的功能码是 `100000`，这些数值都是固定的，查一下 MIPS 指令集的手册就能知道的；
- rs 代表第一个寄存器 R0 的编号，即 `00000`；
- rt 代表第二个寄存器 R1 的编号，即 `00001`；
- rd 代表目标的临时寄存器 R2 的编号，即 `00010`；
- 因为不是位移操作，所以位移量是 `00000`

### 指令流水线
编译器编译时会构造指令, 此时称为指令的编码
CPU 执行指令时会解析指令, 此时称为指令的解码

由于执行一个指令分为很多步, 并且每一步基本都有一个专门负责的 CPU 内部单元负责, 因此可以使用流水线的方式, 将指令的指令流程并行起来

![[Pasted image 20240418140552.png]]
1. CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 **Fetch（取得指令）**；
2. CPU 对指令进行解码，这个部分称为 **Decode（指令译码）**；
3. CPU 执行指令，这个部分称为 **Execution（执行指令）**；
4. CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 **Store（数据回写）**；

这 4 个阶段构成了一个指令的指令周期

不同阶段由 CPU 内部不同的组件完成:
![[Pasted image 20240418140642.png]]


# 磁盘和内存
存储器层次结构:
![[Pasted image 20240418140903.png]]

![[Pasted image 20240418141142.png]]
![[Pasted image 20240418141147.png]]


# 局部性原理
