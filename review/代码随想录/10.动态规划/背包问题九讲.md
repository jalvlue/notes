# 01 背包

### 题目
有 N 件物品和一个容量为 V 的背包, 将第 i 个物品放入背包所消耗的容量是 Ci, 获得的价值是 Wi, 求解将哪些物品装入背包可以使得背包装载的价值最大

### 基本思路
每种物品只有一件, 只有放或者不放两种状态

使用 `F[i, v]` 表示从前 `i` 个物品中选取, 放入容量为 `v` 的背包可以获得的最大价值
根据这两种状态, 可以得到状态转移方程:
`F[i, v] = max(F[i-1, v], F[i-1, v-Ci] + Wi)`

使用这个方程, 将物品 `i` 的放与不放转化为前 `i-1` 个物品相关的问题, 从而获得重叠子问题

迭代伪代码:
```
F[0, 0..V] ← 0
for i ← 1 to N 
	for v ← Ci to V
		F[i, v] ← max{F[i − 1, v], F[i − 1, v − Ci ] + Wi}
```
这里需要注意的是: 内层循环中, 遍历 `v` 从小到大遍历, 实际上从大到小也是可以的, 因为所用到的信息之来自于第 `i-1` 层, 跟第 `i` 层没关系


### 优化空间复杂度
使用滚动数组进行空间优化

从上面的二维地推公式这里可以看出, 第 `i` 层的第 `v` 个元素只依赖于第 `i-1` 层的 `v` 和 `v-Ci` (两个依赖在 v 维度上均在第 `v` 个元素之前
), 
因此可以使用一个一维数组, 
从后往前遍历(满足只取一个元素的条件, 保证计算 `F[v]` 时, `F[v-Ci]` 保存的是 `F[i-1, v-Ci]`)

从而有一维滚动数组递推公式
```
F[0..V ] ←0 
for i ← 1 to N
	for v ← V to Ci
		F[v] ← max{F[v], F[v − Ci ] + Wi}
```
注意: 遍历 `v` 时从后往前遍历


# 完全背包
### 题目
有 N 件物品和一个容量为 V 的背包, 每个物品都有无限件可使用, 将第 i 个物品放入背包所消耗的容量是 Ci, 获得的价值是 Wi, 求解将哪些物品装入背包可以使得背包装载的价值最大

### 基本思路
可以按 01 背包的思路, 将这里转化为取 `0, 1, ..., V/Ci` 件

从而得到递推公式
`F[i, v] = max{F[i − 1, v − kCi ] + kWi | 0 ≤ kCi ≤ v}`

这个思路看似能行, 但是复杂度较高

### O(VN)的算法

```
F[0..V ] ←0
for i ← 1 to N
	for v ← Ci to V
		F[v] ← max(F[v], F[v − Ci ] + Wi)
```
这里的代码与 01 背包非常类似, 只是内层循环的顺序为从 `v` 从小到大遍历

这里有效的想法是:
对于 01 背包, 内层循环 `v` 递减是为了让 `F[i, v]` 严格从 `F[i-1, v-Ci]` 中推出,
也就是在考虑是否选入物品 `i` 时, 依赖的是绝无选入物品 `i` 的子结果 `F[i-1, v-Ci]` 保证只有一个物品 `i` 被选入, 

但对于完全背包, 物品是可选无限个的, 
因此在考虑是否加选一个物品 `i` 时, 需要的是可能已经选入物品 `i` 的子结果, 也就是 `F[i, v-Ci]`


# 多重背包
### 题目
有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。

### 基本思路
对于物品 `i`, 有 `Mi + 1` 种策略: 取 `0, 1, ..., Mi` 件

从而有状态转移方程:
`F[i，v] = max{F[i − 1, v − k ∗ Ci ] + k ∗ Wi | 0 ≤ k ≤ Mi}`

