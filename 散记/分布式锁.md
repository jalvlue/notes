- `distributed lock`

```ad-faq
在并发场景中，为了保证临界资源的数据一致性，我们会经常使用到“锁”这个工具对临界资源进行保护，让混乱的并发访问行为退化为秩序的串行访问行为.

在本地环境中，由于多线程之间能够共享进程的数据，因此可以比较简单地实现进程内的互斥锁；然而在分布式场景中，有时我们需要跨域多个物理节点执行加锁操作，因此我们就需要依赖到类似于 redis、mysql 这样的状态存储组件，在此基础之上实现所谓的“分布式锁”技术.
```


### 分类
![[640.webp]]
- 主动轮询型: 该模型类似于单机锁中的主动轮询 + cas 乐观锁模型，取锁方会持续对分布式锁发出尝试获取动作，如果锁已被占用则会不断发起重试，直到取锁成功为止
- watch 回调型: 在取锁方发现锁已被他人占用时，会创建 watcher 监视器订阅锁的释放事件，随后不再发起主动取锁的尝试；当锁被释放后，取锁方能通过之前创建的 watcher 感知到这一变化，然后再重新发起取锁的尝试动作
- 两者各有优劣, 主动轮询在分布式场景下轮询的网络 IO 等代价可能会更高, 但是主动取锁可以让自己占据主动权; watch 机制在实现过程中需要建立长连接完成 watch 监听动作，也会存在一定的资源损耗, 同时如果有多个使用者尝试获取锁同时 watch 监听同一把锁, 此时释放锁可能会导致 `惊群效应`


### 主动轮询

