GRPC 是一种高性能、开源的远程过程调用（RPC）框架，由 Google 开发并开源。它基于 HTTP/2 协议进行通信，使用 Protocol Buffers（简称 ProtoBuf）作为接口定义语言（IDL）。

RPC 是一种用于不同进程或计算机之间通信的技术，它允许应用程序之间像调用本地函数一样进行通信，隐藏了底层的网络细节。GRPC 建立在 RPC 的概念之上，提供了更高效、更灵活的通信方式。

GRPC 具有以下特点：

1. 高性能：gRPC 使用基于 HTTP/2 的协议进行通信，充分利用了 HTTP/2 的多路复用、头部压缩和流控制等特性，从而实现了高效的数据传输和低延迟的请求响应。

2. 跨语言支持：gRPC 支持多种编程语言，包括但不限于 C++、Java、Python、Go 和 C# 等，这使得不同语言编写的应用程序可以相互通信。

3. 强类型接口定义：gRPC 使用 ProtoBuf 作为接口定义语言，它是一种轻量级、语言无关的序列化机制，可以定义服务接口和数据结构。ProtoBuf 提供了更多的灵活性和可扩展性，使得接口定义更加清晰和易于维护。

4. 支持多种消息传输方式：除了传统的请求-响应模式外，gRPC 还支持流式传输，即客户端和服务器可以通过流式方式发送和接收数据，这对于处理实时数据流或大量数据的场景非常有用。

5. 支持认证和安全性：gRPC 提供了基于 TLS 的身份验证和加密传输，可以确保通信的安全性和可靠性。
由于其性能和灵活性，gRPC 在分布式系统和微服务架构中广泛应用，特别适用于需要高效通信和跨语言支持的场景。

![[Pasted image 20240228184240.png]]
除了 Unary RPC，还有以下几种 RPC 模式：

1. Server Streaming RPC（服务器流式 RPC）：客户端向服务器发送一个请求，服务器返回一个流式的响应。客户端可以通过流式方式获取服务器返回的多个结果。这种模式适用于客户端需要处理大量数据或持续接收流式数据的场景，如实时数据推送、日志流处理等。

2. Client Streaming RPC（客户端流式 RPC）：客户端通过流式方式发送多个请求给服务器，服务器返回一个单一的响应。客户端可以不断发送请求，并在最后接收到服务器的响应。这种模式适用于客户端需要连续发送多个数据或批量操作的场景，如上传文件、批量处理等。

3. Bidirectional Streaming RPC（双向流式 RPC）：客户端和服务器之间建立一个双向的流，双方可以通过流式方式发送多个请求和响应。客户端和服务器可以同时进行读取和写入操作，并且可以根据需要发送和接收多个消息。这种模式适用于需要实现双向通信、交互式的场景，如聊天应用、实时协作等。

这些 RPC 模式可以根据具体的需求选择适合的方式进行通信。它们提供了不同的数据交换和通信方式，适用于不同类型的应用场景。根据业务需求和性能要求，选择合适的 RPC 模式可以提高系统的效率和可扩展性。



下面是一个简单的 gRPC 调用的过程：
1. 定义服务和消息：首先，您需要使用 Protocol Buffers（protobuf）语言定义服务和消息。您定义了要在 gRPC 上使用的服务方法以及每个方法接收和返回的消息类型。

2. 生成代码：使用定义的 protobuf 文件，您可以通过 gRPC 工具生成客户端和服务器端的代码。生成的代码包括服务和消息的类、客户端存根和服务器端桩代码。

3. 实现服务器：在服务器端，您需要编写代码来实现定义的服务接口。这意味着您需要提供服务方法的具体实现逻辑。

4. 启动服务器：在服务器上启动 gRPC 服务器，它会监听指定的端口，等待客户端的连接请求。

5. 创建客户端：在客户端上，您需要创建一个 gRPC 客户端来与服务器进行通信。客户端代码通过调用生成的客户端存根来与服务器进行交互。

6. 发起调用：在客户端上，您可以调用客户端存根上的方法来发起 gRPC 调用。您提供了方法所需的参数，并等待服务器的响应。

7. 序列化和传输：客户端将方法调用的参数序列化为字节流，并通过网络将请求发送到服务器。这通常使用 HTTP/2 协议进行。

8. 服务器处理请求：服务器接收到请求后，将请求进行反序列化，并根据调用的方法找到相应的实现逻辑。服务器执行所需的操作，并准备好响应。

9. 响应返回：服务器将方法的结果序列化为字节流，并通过网络将响应发送回客户端。

10. 客户端处理响应：客户端接收到响应后，将其反序列化为方法返回的结果对象。客户端可以根据需要处理结果，并继续执行其他操作。

以上是一个简单的 gRPC 调用的基本过程。GRPC 还提供了很多高级功能，例如流式调用和身份验证等，可以根据具体的需求进行使用。

# ProtoBuf
Protocol Buffers（ProtoBuf）是一种轻量级、高效的数据序列化机制，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，并且支持多种编程语言。

ProtoBuf 使用类似于 XML 和 JSON 的结构化数据表示方式，但相比之下，它具有更小的数据体积和更高的序列化/反序列化速度。ProtoBuf 的定义文件使用. Proto 扩展名，其中定义了消息的结构和字段，类似于 XML Schema 或 JSON Schema。

ProtoBuf 的主要优势包括：

1. 紧凑的数据表示：ProtoBuf 使用二进制格式进行数据编码，相比于文本格式（如 JSON 和 XML），它生成的数据体积更小，节省了网络带宽和存储空间。

2. 高效的序列化/反序列化：ProtoBuf 的编解码速度非常快，比许多其他序列化框架更高效。这对于需要频繁地在网络上传输和解析大量数据的应用程序非常有利。

3. 跨语言支持：ProtoBuf 支持多种编程语言，包括但不限于 C++、Java、Python、Go 和 C# 等。这意味着不同语言编写的应用程序可以使用相同的 ProtoBuf 定义文件进行数据交换，实现跨语言的数据传输和通信。

4. 可扩展性：ProtoBuf 的定义文件支持向后和向前兼容的演化，允许在不破坏现有数据结构的情况下对消息进行修改和扩展。这使得应用程序可以逐渐演化而不中断现有的数据交换。

5. 自动生成的代码：根据 ProtoBuf 的定义文件，可以使用相应编程语言的 ProtoBuf 编译器生成与消息结构对应的代码，这样可以更方便地进行序列化和反序列化操作。

ProtoBuf 被广泛用于分布式系统、数据存储、通信协议等领域，特别适用于需要高性能、高效数据传输和跨语言通信的场景。

以下是一个简单的示例. Proto 文件，展示了如何定义一个消息和一个服务接口：

```protobuf
syntax = "proto3";

message Person {
  string name = 1;
  int32 age = 2;
  repeated string hobbies = 3;
}

service PersonService {
  rpc GetPersonInfo (PersonRequest) returns (PersonResponse);
}

message PersonRequest {
  string person_id = 1;
}

message PersonResponse {
  string name = 1;
  int32 age = 2;
  repeated string hobbies = 3;
}
```

在这个示例中，定义了一个名为 Person 的消息，它包含了姓名（name）、年龄（age）和爱好（hobbies）字段。接着定义了一个名为 PersonService 的服务，其中包含了一个名为 GetPersonInfo 的 RPC 方法，该方法接收一个 PersonRequest 消息作为参数，并返回一个 PersonResponse 消息作为结果。

使用上述. Proto 文件，可以使用 ProtoBuf 编译器生成相应编程语言的代码，以便在应用程序中进行序列化和反序列化操作。生成的代码将提供与消息结构对应的类或结构体，使得开发者可以方便地创建、传输和解析消息。

该示例展示了如何使用 ProtoBuf 定义消息结构和服务接口，以及如何在服务中定义 RPC 方法。实际应用中，可以根据需要定义更复杂的消息结构和服务接口，并在应用程序中使用 ProtoBuf 进行高效的数据传输和通信。

### protoBuf 消息
在. Proto 文件中，消息（Message）是指用于表示结构化数据的定义。消息是 ProtoBuf 中的基本概念之一，用于描述数据的组织方式和字段的含义。

消息由字段（Field）组成，每个字段都有一个唯一的数字标识符，用于在二进制编码中标识字段。每个字段都具有类型、名称和修饰符。

在. Proto 文件中定义的消息可以包含以下内容：

1. 字段定义：使用字段类型、字段名称和字段修饰符来定义消息的字段。字段类型可以是基本类型（如 bool、int 32、float、string 等）、枚举类型、或者其他自定义消息类型。

2. 嵌套消息定义：消息中可以包含其他消息作为字段类型，形成嵌套的消息结构。嵌套消息可以在. Proto 文件中直接定义，也可以是外部消息类型的内部定义。

3. 枚举定义：在消息中可以定义枚举类型，用于表示一组有限的取值范围。枚举类型的定义在. Proto 文件中独立于消息的定义。

通过定义消息，可以清晰地描述数据的结构和字段的含义。消息提供了一种结构化的数据模型，在序列化、反序列化和数据传输中起着重要的作用。通过使用. Proto 文件定义消息，可以使用 ProtoBuf 编译器生成相应编程语言的代码，以便在应用程序中使用消息并进行序列化、反序列化、数据存储和通信等操作。

###### 字段标识符
字段标识符（Field Identifier）是. Proto 文件中消息字段的唯一数字标识符，用于在二进制编码中标识字段的位置。

每个字段在消息中都有一个字段标识符，它是一个正整数。字段标识符的作用是确保在序列化和反序列化过程中，可以准确地识别和定位消息中的字段。

字段标识符在. Proto 文件中的定义顺序并不重要，因为它们在编码过程中会被重新映射为相对于消息的偏移量。在. Proto 文件中，字段标识符的值是为了开发人员的可读性而设定的，但在实际编码中，它们会被编码为更紧凑的格式。

在. Proto 文件中，字段标识符的定义形式为：`字段名称 = 标识符;`。例如，`string username = 1;` 中的 `1` 就是字段标识符。

在序列化时，字段标识符会与字段的值一起编码为二进制格式，以便在反序列化时可以正确地识别和解码字段。通过字段标识符，可以在不依赖字段顺序的情况下，准确地将字段值还原为原始消息的结构。

字段标识符的选择应该是唯一且有意义的，避免重复和混淆。通常建议使用自增的正整数作为字段标识符，以便于后续的扩展和演化。

字段标识符在 ProtoBuf 中的存在有以下几个作用和意义：

1. 唯一标识字段：字段标识符确保了每个字段在消息中的唯一性。通过字段标识符，不同的字段可以被准确地识别和定位，避免混淆和歧义。

2. 支持字段的增删和顺序变更：字段标识符的定义不依赖于字段在. Proto 文件中的顺序。这意味着可以在消息定义中增加、删除或重新排列字段，而不会影响已经序列化的数据的兼容性。在反序列化时，通过字段标识符，可以将字段值准确地还原到对应的字段上，而不受字段顺序变化的影响。

3. 版本兼容性和演化：字段标识符在消息定义的演化和版本兼容性方面起着重要作用。如果对已有消息进行扩展或修改，可以通过添加新的字段标识符来引入新的字段，而不会破坏已有数据的解析。旧版本的解析器会忽略它们不认识的字段标识符，从而实现了向后兼容性。

4. 优化编码效率：字段标识符在编码过程中被映射为更紧凑的格式，以便减少所需的编码字节数。通过使用字段标识符，可以在编码时只编码字段标识符和字段值，而不需要编码字段名等其他信息，从而提高了编码的效率和性能。

总的来说，字段标识符在 ProtoBuf 中的作用是确保字段的唯一性、支持消息的演化和版本兼容性，以及优化编码效率。它是序列化和反序列化过程中的重要组成部分，通过字段标识符，ProtoBuf 可以准确地识别和解析消息中的字段，实现灵活、高效的数据交换和通信。

### protoBuf 语法
以下是一些具体的 ProtoBuf 语法示例：

1. 定义一个简单的消息：
```protobuf
message Person {
  string name = 1;
  int32 age = 2;
  bool is_student = 3;
}
```
上述示例定义了一个名为 Person 的消息，它包含了姓名（name）、年龄（age）和是否学生（is_student）三个字段。

2. 定义一个枚举类型：
```protobuf
enum Gender {
  UNKNOWN = 0;
  MALE = 1;
  FEMALE = 2;
}
```
上述示例定义了一个名为 Gender 的枚举类型，包含了 UNKNOWN、MALE 和 FEMALE 三个枚举值。

3. 定义一个嵌套消息：
```protobuf
message Address {
  string street = 1;
  string city = 2;
}

message Person {
  string name = 1;
  int32 age = 2;
  Address address = 3;
}
```
上述示例中，Person 消息中嵌套了一个 Address 消息，用于表示人的地址信息。

4. 定义一个重复字段：
```protobuf
message Person {
  string name = 1;
  repeated string phone_numbers = 2;
}
```
上述示例中，Person 消息包含了一个重复字段 phone_numbers，可以用于存储多个电话号码。

5. 定义一个服务和 RPC 方法：
使用 `service` 关键字可以定义一个服务, 使用 `rpc` 关键字可以在这个服务内定义一个 rpc 方法(同时指定好 rpc 类型和参数、返回值, 其中参数、返回值就是使用 `message` 关键字定义的消息)

```protobuf
service PersonService {
  rpc GetPersonInfo (PersonRequest) returns (PersonResponse);
}

message PersonRequest {
  string person_id = 1;
}

message PersonResponse {
  string name = 1;
  int32 age = 2;
}
```
上述示例定义了一个名为 PersonService 的服务，其中包含了一个名为 GetPersonInfo 的 RPC 方法，它接收一个 PersonRequest 消息作为输入，并返回一个 PersonResponse 消息作为输出。

这些示例展示了 ProtoBuf 的语法在定义消息、枚举、嵌套消息、重复字段和服务接口中的应用。实际应用中，可以根据需求使用 ProtoBuf 的语法来定义更复杂的消息结构和服务接口。

# protoc
protoc（Protocol Buffers Compiler）是Google开发的用于生成各种编程语言的代码的工具。它是Protocol Buffers（简称ProtoBuf）的官方编译器，用于将.proto文件中定义的消息类型转换为特定编程语言的类、结构体或接口等代码。

protoc是一个命令行工具，可以通过指定输入的.proto文件和输出的目标语言，生成相应的代码文件。它支持多种编程语言，包括但不限于C++, Java, Python, Go, C#, Ruby, JavaScript等。

使用protoc的一般步骤如下：

1. 编写.proto文件：首先，需要编写一个.proto文件，定义消息类型、字段和其他相关信息。在.proto文件中，使用ProtoBuf的语法来描述数据结构和字段的含义。

2. 运行protoc命令：在命令行中运行protoc命令，指定输入的.proto文件和输出的目标语言。

   例如，`protoc --proto_path=path/to/proto/files --<language>_out=output/directory file.proto`。
   
   其中，`--proto_path`用于指定.proto文件的搜索路径，`--<language>_out`用于指定目标语言和输出目录，`file.proto`是要编译的.proto文件名。

3. 生成代码文件：protoc会读取.proto文件，并根据指定的目标语言生成相应的代码文件。生成的代码文件可以包含用于序列化、反序列化、访问消息字段等功能的类、结构体、接口或模块，根据目标语言的习惯和规范而定。

4. 在应用程序中使用生成的代码：将生成的代码文件导入到应用程序中，并使用其中定义的类、结构体或接口来操作和处理消息数据。可以使用生成的代码进行消息的序列化、反序列化、数据存储、网络传输等操作。

protoc 的优点是它可以根据.proto 文件的定义，自动生成代码，减少了手动编写和维护大量重复的数据传输和序列化代码的工作。它提供了一种快速、简洁、跨语言的数据交换解决方案，广泛应用于分布式系统、网络通信和数据存储等领域。

使用 protoc 根据指定的 `proto` 文件, 一般会生成两个新文件:
- `xxx.pb.go`: 包含了用于填充、序列化、`proto message <-> go struct` 之间转化的代码
- `xxx_grpc.pb.go`: 包含了
	- 一个服务客户端接口和一个简单实现
	- 一个服务服务端接口 (需要自己实现)

# 创建 grpc 服务器
1. 根据服务端接口, 自己实现一个真正提供服务的服务端
2. 运行这个 grpc 服务器, 监听客户端请求, 并将请求正确转发

根据实际需求, 实现了这个 grpc 服务器接口之后, 就可以运行监听服务
```go
lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", port))
if err != nil {
  log.Fatalf("failed to listen: %v", err)
}
var opts []grpc.ServerOption
...
grpcServer := grpc.NewServer(opts...)
pb.RegisterRouteGuideServer(grpcServer, newServer())
grpcServer.Serve(lis)
```
1. 指定监听端口
2. 新建一个 grpc 服务器(`grpc.NewServer(...)`)
3. 将服务实现注册到这个 grpc 服务器上 (使用生成的 `pb.RegisterRouteGuideServer()` 方法)
4. 调用 grpc 服务器的 `Serve` 方法开始提供服务

在使用 gRPC 构建服务器时，需要先创建一个 gRPC 服务器对象，然后将你编写的服务实现注册到这个服务器中。这是因为 gRPC 框架提供了一种基于接口定义语言（IDL）的服务定义方式，即使用 Protocol Buffers（简称 Protobuf）定义服务接口和消息格式。

通过 Protobuf 定义服务接口和消息格式，可以实现跨多种编程语言的客户端和服务器之间的互操作性。GRPC 使用 Protobuf 来生成客户端和服务器端的代码，使得它们可以相互通信，并且在不同的语言环境中保持一致。

在这个过程中，你编写的服务实现是基于定义的服务接口进行开发的，它包含了具体的服务逻辑。然而，服务实现本身并不具备网络通信的功能。因此，需要将你编写的服务实现注册到 gRPC 服务器中，以便服务器能够处理客户端的请求，并将请求转发给相应的服务实现。

通过将服务实现注册到 gRPC 服务器中，服务器能够根据客户端请求的方法调用相应的服务实现代码，并将结果返回给客户端。这种注册的方式使得服务器能够动态地处理多个不同的服务实现，并保证了整个系统的灵活性和可扩展性。

因此，需要先创建一个 gRPC 服务器对象，然后将你编写的服务实现注册到服务器中，以便服务器能够提供相应的服务功能并与客户端进行通信。


# 创建 grpc 客户端
1. 与 grpc 服务器建立连接
2. 根据这个连接创建客户端调用服务

```go
var opts []grpc.DialOption
...
conn, err := grpc.Dial(*serverAddr, opts...)
if err != nil {
  ...
}
defer conn.Close()

client := pb.NewRouteGuideClient(conn)

feature, err := client.GetFeature(context.Background(), &pb.Point{409146138, -746188906})
if err != nil {
  ...
}
```

在客户端中, grpc 已经生成了一个默认的客户端实现, 可以直接使用 `pb.NewRouteGuideClient()` 创建默认的客户端


