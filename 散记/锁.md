# 乐观锁和悲观锁
- 悲观锁: 认为自己在访问临界资源的时候, 最坏的情况始终可能发生 (也就是认为其他线程随时可能修改数据), 因此访问前就加锁, 每次只有一个线程可以访问数据
	- 开销大
	- 适合并发写多的场景
- 乐观锁: 认为自己访问数据时, 发生冲突的可能性很小, 因此不加锁, 而是更新数据时进行版本检查, 通过版本控制判断数据是否被修改
	- 使用并发读较多的场景
	- 只有提交更新 (写)操作时才进行版本检查, 开销小
	- 可能会因冲突而重试

# 自旋锁和互斥锁
自旋锁（spinlock）和互斥锁（mutex）的效率取决于使用场景和系统环境。没有绝对的答案，因为每种锁机制都有其适用的场景。
自旋锁的优势：
- 在锁被占用的时间非常短的情况下，自旋锁可能更高效，因为它避免了线程切换的开销。
- 自旋锁的实现通常更简单，因此锁的获取和释放可能会更快。
互斥锁的优势：
- 当锁被占用的时间较长或者线程优先级不同时，互斥锁更有效，因为它们允许等待锁的线程进入睡眠状态，从而让出 CPU 给其他线程使用。
- 在多处理器系统中，互斥锁可以更好地利用系统的并发性，因为线程等待锁时不会占用 CPU 资源。
在 Go 语言中，`sync.Mutex` 是一个互斥锁，它被设计为在锁不可用时，等待的 goroutine 会让出 CPU，这有利于减少 CPU 资源的浪费，并提高系统的整体性能。此外，Go 的运行时调度器会处理 goroutine 的切换，使得互斥锁在大多数情况下都是高效的选择。

总之，选择自旋锁还是互斥锁取决于具体的应用场景和性能考量。在锁占用时间短且争用激烈的情况下，自旋锁可能更合适；而在锁占用时间长或者系统需要减少 CPU 占用的情况下，互斥锁可能是更好的选择。在实际应用中，通常需要通过性能测试来确定哪种锁机制更适合特定的场景。
